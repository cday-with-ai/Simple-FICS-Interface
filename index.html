<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simple FICS Interface</title>
    <style>

        body {
          font-family: Arial, sans-serif;
          margin: 20px;
        }
        #title {
          color: blue;
          margin-left: 15px;
          text-align: center;
        }
        .grid-container {
          display: grid;
        }
        .grid-row {
          display: grid;
          margin-top: 10px;
        }

        /* Main container layout */
        .main-container {
            display: flex;
            flex-direction: column;
            width: 100%;
            height: calc(100vh - 100px); /* Adjust based on your header size */
        }

        /* Top section with chess tabs and right side content */
        .top-section {
            display: flex;
            width: 100%;
            height: 100%;
            position: relative;
        }

        /* Chess tabs on the left */
        .chess-tabs {
            flex: 0 0 50%;
            overflow-x: auto; /* Allow horizontal scrolling */
            overflow-y: hidden; /* Prevent vertical scrolling */
            border-right: 1px solid #ccc;
            display: flex;
            flex-direction: column;
        }

        /* Right side content container */
        .right-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            position: relative;
        }

        /* Main console on the top right */
        .main-console {
            flex: 0 0 60%;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            border-bottom: 1px solid #ccc;
            margin-left: 20px;
        }

        /* Make the grid container fill the main console */
        .main-console .grid-container {
            display: flex;
            flex-direction: column;
            height: 100%;
        }

        /* Chat tabs on the bottom right */
        .chat-tabs-container {
            flex: 1;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        /* Make tab content fill available space */
        .chat-tabs-container .tab-content {
            height: 100%;
            display: flex;
            flex-direction: column;
        }

        /* Ensure tab set takes full width but minimal height */
        .chat-tabs-container #tabset {
            display: flex;
            flex-direction: column;
            height: 100%;
        }

        /* Horizontal resizable divider (between chess tabs and right content) */
        .horizontal-divider {
            width: 10px;
            background-color: #f0f0f0;
            cursor: col-resize;
            border-left: 1px solid #ccc;
            border-right: 1px solid #ccc;
            position: absolute;
            top: 0;
            bottom: 0;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* Divider control buttons container */
        .divider-controls {
            position: absolute;
            display: flex;
            flex-direction: column; /* Stack buttons vertically */
            background-color: transparent; /* Make container transparent */
            z-index: 11;
            left: 4px; /* Shift 4px to the right from center */
            transform: translateX(-50%);
        }

        /* Triangle buttons for collapsing divider */
        .triangle-button {
            width: 8px;
            height: 8px;
            padding: 0;
            background-color: #f0f0f0;
            border: none; /* Remove borders */
            cursor: pointer;
            font-size: 8px; /* Smaller font size */
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.2s;
        }

        .triangle-button:hover {
            background-color: #e0e0e0;
        }

        .triangle-button:active {
            background-color: #d0d0d0;
        }

        /* Vertical resizable divider (between main console and chat tabs) */
        .vertical-divider {
            height: 10px;
            background-color: #f0f0f0;
            cursor: row-resize;
            border-top: 1px solid #ccc;
            border-bottom: 1px solid #ccc;
            position: absolute;
            left: 0;
            right: 0;
            top: 50%; /* Default to 50% */
            transform: translateY(-50%);
            z-index: 10;
            transition: opacity 0.2s ease; /* Smooth transition when showing/hiding */
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* Vertical divider controls */
        .divider-controls.vertical {
            flex-direction: row; /* Horizontal arrangement for vertical divider */
            left: 50%; /* Center horizontally */
            transform: translateX(-50%); /* Center the control precisely */
        }

        /* Ensure buttons on both dividers have the same size */
        .divider-controls.vertical .triangle-button {
            width: 8px; /* Match horizontal divider button width */
            height: 8px; /* Match horizontal divider button height */
            font-size: 8px; /* Match horizontal divider button font size */
        }

        .divider:hover {
            background-color: #ddd;
        }

        /* Tab styles for both sections */
        .chess-tabs .tabset, .chat-tabs-container .tabset {
            width: 100%;
            overflow-x: auto;
            overflow-y: hidden; /* Prevent vertical scrolling */
            white-space: nowrap;
        }

        /* Specific styles for chess tabs */
        .chess-tabs .tabset {
            height: auto; /* Adjust height to content */
        }

        /* Ensure chess tab content doesn't scroll vertically */
        .chess-tabs .tab-content {
            overflow-y: hidden; /* Prevent vertical scrolling */
            overflow-x: auto; /* Allow horizontal scrolling if needed */
        }

        /* Make grid containers fill their parent */
        .chess-tabs .grid-container, .main-console .grid-container, .chat-tabs-container .grid-container {
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        /* Make text areas fill available space */
        .ics-text-area, .tab-text-area {
            flex: 1;
            min-height: 100px;
            width: 100%;
            box-sizing: border-box;
            resize: none; /* Prevent manual resizing */
            background-color: blue;
            color: white;
            font-family: 'Courier New', Courier, Monospace;
            font-size: medium;
            font-weight: bold;
        }
        .ics-input {
          vertical-align: top;
          width: 100%;
          height: 24px; /* Fixed height for the input */
          overflow: hidden;
          font-weight: bold;
          border-width: 2px;
          padding: 2px 2px;
          background-color: blue;
          color: white;
        }
        .tab-Input {
          vertical-align: top;
          width: 100%;
          overflow: hidden;
          font-weight: bold;
          border-width: 2px;
          padding: 2px 2px;
          background-color: blue;
          color: white;
          max-height: 18px;
        }
        .tab-input-label {
          font-weight: bold;
          color: blue;
          padding-top: 2px;
          padding-bottom: 2px;
          padding-right: 5px;
        }
        .tabset {
            margin: 20px auto;
            width: 100%;
        }
        .tabs {
            display: flex;
        }
        .tab {
            padding: 10px 20px;
            cursor: pointer;
            background: #f1f1f1;
            margin-right: 5px;
            border-radius: 5px 5px 0 0;
            position: relative;
            top: 2px;
        }
        .tab-active {
            background: #fff;
            border: 1px solid #ADD8E6;
            border-bottom: none;
            color: blue;
        }
        .tab-inactive {
        }
        .tab-content {
            padding: 20px;
            background: #fff;
            display: none; /* Hidden by default */
            flex-direction: column; /* For proper layout of children */
            height: 100%; /* Fill available height */
        }
        .tab-content-active {
            display: flex; /* Show as flex when active */
        }
        .tab-content-inactive {
            display: none; /* Hide when inactive */
        }
        .close-btn {
            position: relative;
            top: -5px;
            color: #ff0000;
            cursor: pointer;
            font-weight: bold;
            font-size: small;
        }
        .close-btn:hover {
            color: #cc0000;
        }
        .chess-board-container {
            position: relative;
            margin: 20px auto;
            display: inline-block;
        }
        .chess-board {
            width: 400px;
            height: 400px;
            border: 2px solid #333;
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            margin: 0 auto;
            position: relative;
            resize: both;
            overflow: hidden;
            min-width: 200px;
            min-height: 200px;
            max-width: 800px;
            max-height: 800px;
            aspect-ratio: 1 / 1; /* Force square aspect ratio */
        }
        .chess-square {
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 36px;
            cursor: pointer;
            position: relative;
        }
        .chess-piece {
            position: absolute;
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100%;
            height: 100%;
            z-index: 1;
            cursor: grab;
        }

        .chess-piece.dragging {
            position: fixed;
            width: 50px;
            height: 50px;
            pointer-events: none;
            z-index: 1000;
            opacity: 0.8;
            transform: translate(-50%, -50%);
        }
        .chess-piece img {
            width: 95%;
            height: 95%;
            object-fit: contain;
        }
        .light-square {
            background-color: #e8e0c8; /* Default lighter beige color - will be overridden by preferences */
        }
        .dark-square {
            background-color: #AB8B69; /* Default darker brown color - will be overridden by preferences */
        }
        .rank-label {
            position: absolute;
            top: 2px;
            right: 2px;
            left: auto !important; /* Force right alignment */
            font-size: 10px;
            font-weight: bold;
            color: white;
            opacity: 0.7;
            text-shadow: 0px 0px 2px #000;
            pointer-events: none;
            z-index: 5;
        }
        .file-label {
            position: absolute;
            bottom: 2px;
            right: 2px;
            font-size: 10px;
            font-weight: bold;
            color: white;
            opacity: 0.7;
            text-shadow: 0px 0px 2px #000;
            pointer-events: none;
            z-index: 5;
        }
        .resize-handle {
            position: absolute;
            right: 0;
            bottom: 0;
            width: 15px;
            height: 15px;
            background-color: #555;
            cursor: nwse-resize;
            border-top-left-radius: 3px;
            z-index: 10;
        }
        /* Add diagonal lines to the resize handle to make it more visible */
        .resize-handle::before {
            content: '';
            position: absolute;
            right: 3px;
            bottom: 3px;
            width: 6px;
            height: 1px;
            background-color: #fff;
            transform: rotate(-45deg);
        }
        .resize-handle::after {
            content: '';
            position: absolute;
            right: 6px;
            bottom: 6px;
            width: 6px;
            height: 1px;
            background-color: #fff;
            transform: rotate(-45deg);
        }
        .selected {
            background-color: rgba(173, 216, 230, 0.7) !important; /* Light blue highlight */
        }
        .valid-move {
            background-color: rgba(144, 238, 144, 0.5) !important; /* Light green highlight */
        }
        .game-controls {
            margin-top: 10px;
        }
        .game-controls button {
            margin-right: 10px;
            padding: 5px 10px;
        }
        .game-status {
            font-weight: bold;
            margin-top: 5px;
            color: blue;
        }

        /* Hamburger Menu Styles */
        .hamburger-menu {
            position: absolute;
            top: 15px;
            left: 10px;
            cursor: pointer;
            z-index: 1000;
            font-size: 24px;
        }

        .preferences-panel {
            position: absolute;
            top: 10px;
            left: 30px;
            background-color: white;
            border: 1px solid #ccc;
            border-radius: 5px;
            padding: 5px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            z-index: 999;
            width: 250px;
            display: none;
        }

        .preferences-panel.show {
            display: flex;
        }

        .preferences-panel:not(.show) {
            display: none;
        }

        .preferences-panel h3 {
            margin-top: 0;
            margin-bottom: 10px;
            border-bottom: 1px solid #eee;
            padding-bottom: 5px;
        }

        .preference-group {
            margin-bottom: 15px;
        }

        .preference-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }

        .preference-group select,
        .preference-group input {
            width: 100%;
            padding: 5px;
            margin-bottom: 10px;
        }

        .color-preview {
            display: inline-block;
            width: 40px;
            height: 40px;
            border: 1px solid #ccc;
            vertical-align: middle;
            margin-left: 10px;
        }

        /* Preferences Panel Category Styles */
        .preferences-panel {
            display: flex;
            width: 500px;
            max-height: 80vh;
            overflow-y: auto;
        }

        .preferences-panel h3 {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            margin: 0;
            padding: 10px 15px;
            background-color: #f1f1f1;
            border-bottom: 1px solid #ccc;
            box-sizing: border-box;
        }

        .pref-categories {
            display: flex;
            flex-direction: column;
            width: 120px;
            background-color: #f1f1f1;
            border-right: 1px solid #ccc;
            padding-top: 40px; /* Space for the header */
        }

        .pref-category {
            padding: 12px 10px;
            cursor: pointer;
            border-bottom: 1px solid #ddd;
            text-align: left;
        }

        .pref-category.active {
            background-color: #fff;
            border-right: none;
            font-weight: bold;
        }

        .pref-content-container {
            flex: 1;
            padding: 15px;
            padding-top: 50px; /* Space for the header */
            padding-bottom: 60px; /* Space for the save button */
            position: relative;
        }

        .pref-content {
            display: none;
        }

        .pref-content.active {
            display: block;
        }

        .save-button-container {
            position: absolute;
            bottom: 15px;
            right: 15px;
            z-index: 10;
        }

        #savePreferences {
            padding: 8px 15px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
        }

        #savePreferences:hover {
            background-color: #45a049;
        }

        /* Piece Set Preview Styles */
        .piece-set-preview {
            width: 100%;
            border: 1px solid #ccc;
            border-radius: 4px;
            margin-top: 5px;
            background-color: #f9f9f9;
        }

        .preview-row {
            display: flex;
            justify-content: space-around;
        }

        .preview-cell {
            width: 40px;
            height: 40px;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .preview-cell img {
            max-width: 30px;
            max-height: 30px;
        }
    </style>
</head>
<body>
<!-- Hamburger Menu -->
<div class="hamburger-menu" id="hamburgerMenu">☰</div>

<h2 id="title">Simple FICS Interface</h2>

<!-- Preferences Panel -->
<div class="preferences-panel" id="preferencesPanel">
    <h3>Preferences</h3>

    <!-- Category Tabs (Left Side) -->
    <div class="pref-categories">
        <div class="pref-category" data-category="fics">FICS</div>
        <div class="pref-category active" data-category="chessboard">Chess Board</div>
        <div class="pref-category" data-category="tabs">Tabs</div>
    </div>

    <!-- Content Container (Right Side) -->
    <div class="pref-content-container">
        <!-- FICS Preferences -->
        <div class="pref-content" id="pref-fics">
            <div class="preference-group">
                <label for="prefFicsUsername">FICS Username:</label>
                <input type="text" id="prefFicsUsername" placeholder="Enter your FICS username">
            </div>

            <div class="preference-group">
                <label for="prefFicsPassword">FICS Password:</label>
                <input type="password" id="prefFicsPassword" placeholder="Enter your FICS password">
                <div class="password-info" style="font-size: 12px; margin-top: 5px; color: #666;">
                    <i>Your password is stored locally and used only for FICS authentication.</i>
                </div>
            </div>

            <div class="preference-group">
                <label for="prefAutoLogin">Auto Login:</label>
                <div style="display: flex; align-items: center;">
                    <input type="checkbox" id="prefAutoLogin" style="width: auto; margin-right: 5px;" checked>
                    <span>Automatically login when connecting to FICS</span>
                </div>
            </div>
        </div>

        <!-- Chess Board Preferences -->
        <div class="pref-content active" id="pref-chessboard">
            <div class="preference-group">
                <label for="prefPieceSet">Chess Piece Set:</label>
                <select id="prefPieceSet">
                    <option value="alpha">Alpha</option>
                    <option value="anarcandy">Anarcandy</option>
                    <option value="california">California</option>
                    <option value="cardinal">Cardinal</option>
                    <option value="cburnett">Cburnett</option>
                    <option value="celtic">Celtic</option>
                    <option value="chess7">Chess7</option>
                    <option value="chessnut">Chessnut</option>
                    <option value="companion">Companion</option>
                    <option value="disguised">Disguised</option>
                    <option value="dubrovny">Dubrovny</option>
                    <option value="fantasy">Fantasy</option>
                    <option value="fresca">Fresca</option>
                    <option value="gioco">Gioco</option>
                    <option value="governor">Governor</option>
                    <option value="horsey">Horsey</option>
                    <option value="icpieces">Icpieces</option>
                    <option value="kiwen-suwi">Kiwen-Suwi</option>
                    <option value="kosal">Kosal</option>
                    <option value="leipzig">Leipzig</option>
                    <option value="letter">Letter</option>
                    <option value="libra">Libra</option>
                    <option value="maestro">Maestro</option>
                    <option value="merida">Merida</option>
                    <option value="mpchess">Mpchess</option>
                    <option value="pirouetti">Pirouetti</option>
                    <option value="pixel">Pixel</option>
                    <option value="reillycraig">Reillycraig</option>
                    <option value="riohacha">Riohacha</option>
                    <option value="shapes">Shapes</option>
                    <option value="spatial">Spatial</option>
                    <option value="staunty">Staunty</option>
                    <option value="tatiana">Tatiana</option>
                </select>
            </div>

            <div class="preference-group">
                <label>Piece Set Preview:</label>
                <div id="pieceSetPreview" class="piece-set-preview">
                    <!-- 5x4 grid for piece preview -->
                    <div class="preview-row">
                        <div class="preview-cell"><img id="preview-bR" src="" alt="bR"></div>
                        <div class="preview-cell"><img id="preview-bN" src="" alt="bN"></div>
                        <div class="preview-cell"><img id="preview-bB" src="" alt="bB"></div>
                        <div class="preview-cell"><img id="preview-bQ" src="" alt="bQ"></div>
                        <div class="preview-cell"><img id="preview-bK" src="" alt="bK"></div>
                    </div>
                    <div class="preview-row">
                        <div class="preview-cell"><img id="preview-bP" src="" alt="bP"></div>
                        <div class="preview-cell"><img id="preview-bP" src="" alt="bP"></div>
                        <div class="preview-cell"><img id="preview-bP" src="" alt="bP"></div>
                        <div class="preview-cell"><img id="preview-bP" src="" alt="bP"></div>
                        <div class="preview-cell"><img id="preview-bP" src="" alt="bP"></div>
                    </div>
                    <div class="preview-row">
                        <div class="preview-cell"><img id="preview-wP" src="" alt="wP"></div>
                        <div class="preview-cell"><img id="preview-wP" src="" alt="wP"></div>
                        <div class="preview-cell"><img id="preview-wP" src="" alt="wP"></div>
                        <div class="preview-cell"><img id="preview-wP" src="" alt="wP"></div>
                        <div class="preview-cell"><img id="preview-wP" src="" alt="wP"></div>
                    </div>
                    <div class="preview-row">
                        <div class="preview-cell"><img id="preview-wR" src="" alt="wR"></div>
                        <div class="preview-cell"><img id="preview-wN" src="" alt="wN"></div>
                        <div class="preview-cell"><img id="preview-wB" src="" alt="wB"></div>
                        <div class="preview-cell"><img id="preview-wQ" src="" alt="wQ"></div>
                        <div class="preview-cell"><img id="preview-wK" src="" alt="wK"></div>
                    </div>
                </div>
            </div>

            <div class="preference-group">
                <label for="prefLightSquare">Light Square Color:</label>
                <div style="display: flex; align-items: center;">
                    <input type="color" id="prefLightSquare" value="#e8e0c8" style="width: 60px;">
                    <div class="color-preview" id="lightSquarePreview" style="background-color: #e8e0c8;"></div>
                </div>
            </div>

            <div class="preference-group">
                <label for="prefDarkSquare">Dark Square Color:</label>
                <div style="display: flex; align-items: center;">
                    <input type="color" id="prefDarkSquare" value="#AB8B69" style="width: 60px;">
                    <div class="color-preview" id="darkSquarePreview" style="background-color: #AB8B69;"></div>
                </div>
            </div>

        </div>

        <!-- Tabs Preferences -->
        <div class="pref-content" id="pref-tabs">
            <div class="preference-group">
                <label>Message Routing:</label>

                <div style="margin-top: 10px;">
                    <div style="display: flex; align-items: center; margin-bottom: 8px;">
                        <input type="checkbox" id="prefChannelTellsToTabs" style="width: auto; margin-right: 10px;" checked>
                        <label for="prefChannelTellsToTabs" style="font-weight: normal;">Send all channel tells to channel tabs</label>
                    </div>

                    <div style="display: flex; align-items: center; margin-bottom: 8px;">
                        <input type="checkbox" id="prefDirectTellsToTabs" style="width: auto; margin-right: 10px;" checked>
                        <label for="prefDirectTellsToTabs" style="font-weight: normal;">Send all direct tells to direct tell tab</label>
                    </div>

                    <div style="display: flex; align-items: center; margin-bottom: 8px;">
                        <input type="checkbox" id="prefGameTellsToTabs" style="width: auto; margin-right: 10px;" checked>
                        <label for="prefGameTellsToTabs" style="font-weight: normal;">Send all game tells to game tab</label>
                    </div>
                </div>
            </div>

            <div class="preference-group">
                <label>Tab Behavior:</label>

                <div style="margin-top: 10px;">
                    <div style="display: flex; align-items: center; margin-bottom: 8px;">
                        <input type="checkbox" id="prefAutoSwitchToNewTabs" style="width: auto; margin-right: 10px;" checked>
                        <label for="prefAutoSwitchToNewTabs" style="font-weight: normal;">Automatically switch to new tabs when created</label>
                    </div>

                    <div style="display: flex; align-items: center; margin-bottom: 8px;">
                        <input type="checkbox" id="prefFlashTabsOnActivity" style="width: auto; margin-right: 10px;" checked>
                        <label for="prefFlashTabsOnActivity" style="font-weight: normal;">Flash tabs on new activity</label>
                    </div>
                </div>
            </div>
        </div>

        <!-- Save Button (Bottom Right) -->
        <div class="save-button-container">
            <button id="savePreferences">Save Preferences</button>
        </div>
    </div>
</div>
<div class="main-container">
    <!-- Top section with chess tabs and right side content -->
    <div class="top-section">
        <!-- Chess board tabs (left side) -->
        <div class="chess-tabs">
            <div id="chessTabset" class="tabset">
                <div id="chessTabs" class="tabs"></div>
            </div>
        </div>

        <!-- Horizontal resizable divider with collapse buttons -->
        <div class="divider horizontal-divider" id="topDivider">
            <div class="divider-controls">
                <button id="collapseLeft" class="triangle-button" title="Collapse to left">◀</button>
                <button id="collapseRight" class="triangle-button" title="Collapse to right">▶</button>
            </div>
        </div>

        <!-- Right side content (main console and chat tabs) -->
        <div class="right-content">
            <!-- Main console (top right) -->
            <div class="main-console">
                <div class="grid-container">
                    <div class="grid-row" style="flex: 1; display: flex; flex-direction: column;">
                        <textarea id="mainTextArea" class="ics-text-area" readonly style="flex: 1; min-height: 100px; max-height: calc(100% - 15px);"></textarea>
                    </div>
                    <div class="grid-row" style="padding-bottom: 15px; margin-top: 0px">
                        <input id="mainInput" class="ics-input"/>
                    </div>
                </div>
            </div>

            <!-- Vertical resizable divider with collapse buttons -->
            <div class="divider vertical-divider" id="rightDivider" style="display: none;margin-left: 3px">
                <div class="divider-controls vertical">
                    <button id="collapseUp" class="triangle-button" title="Collapse upward">▲</button>
                    <button id="collapseDown" class="triangle-button" title="Collapse downward">▼</button>
                </div>
            </div>

            <!-- Chat tabs (bottom right) -->
            <div class="chat-tabs-container">
                <div id="tabset" class="tabset">
                    <div id="tabs" class="tabs"></div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.10.2/chess.min.js"></script>
<script>
    const wsUrl = 'wss://www.freechess.org:5001';
    const mainTextArea = document.getElementById('mainTextArea');
    const mainInput = document.getElementById('mainInput');
    const statusDiv = document.getElementById('status');
    const tabSet = document.getElementById('tabset');
    const tabs = document.getElementById('tabs');
    const chessTabSet = document.getElementById('chessTabset');
    const chessTabs = document.getElementById('chessTabs');
    let chess = new Chess(); // Using the chess.js library
    let selectedSquare = null;
    let validMoves = [];
    let gameTabId = null;
    let myColor = 'white'; // Will be updated based on game info
    let isLoggingIn = false;
    let ws = null;

    // Set up the resizable dividers
    const topDivider = document.getElementById('topDivider');
    const rightDivider = document.getElementById('rightDivider');
    const chessTabsContainer = document.querySelector('.chess-tabs');
    const rightContent = document.querySelector('.right-content');
    const mainConsole = document.querySelector('.main-console');
    const chatTabsContainer = document.querySelector('.chat-tabs-container');

    // Variables to track which divider is being dragged
    let activeResizer = null;

    // Add event listeners for the horizontal divider (between chess tabs and right content)
    topDivider.addEventListener('mousedown', function(e) {
        // Only start resize if the click is on the divider itself, not on the buttons
        if (e.target === topDivider) {
            e.preventDefault();
            activeResizer = 'horizontal';
            document.addEventListener('mousemove', resizeDividers);
            document.addEventListener('mouseup', stopResize);
        }
    });

    // Add event listeners for the collapse buttons
    const collapseLeftBtn = document.getElementById('collapseLeft');
    const collapseRightBtn = document.getElementById('collapseRight');

    collapseLeftBtn.addEventListener('click', function() {
        // Collapse to the left (hide chess tabs)
        chessTabsContainer.style.flexBasis = '0%';
        topDivider.style.left = '0%';
        // Scroll consoles to bottom after collapsing with a delay
        setTimeout(scrollConsolesToBottom, 100);
    });

    collapseRightBtn.addEventListener('click', function() {
        // Collapse to the right (maximize chess tabs)
        chessTabsContainer.style.flexBasis = '100%';
        topDivider.style.left = '100%';
        // Scroll consoles to bottom after collapsing with a delay
        setTimeout(scrollConsolesToBottom, 100);
    });

    // Add event listeners for the vertical divider (between main console and chat tabs)
    rightDivider.addEventListener('mousedown', function(e) {
        // Only start resize if the click is on the divider itself, not on the buttons
        if (e.target === rightDivider) {
            e.preventDefault();
            activeResizer = 'vertical';
            document.addEventListener('mousemove', resizeDividers);
            document.addEventListener('mouseup', stopResize);
        }
    });

    // Add event listeners for the vertical collapse buttons
    const collapseUpBtn = document.getElementById('collapseUp');
    const collapseDownBtn = document.getElementById('collapseDown');

    collapseUpBtn.addEventListener('click', function() {
        // Collapse upward (maximize main console)
        mainConsole.style.flexBasis = '100%';
        rightDivider.style.top = '100%';
        // Scroll consoles to bottom after collapsing with a delay
        setTimeout(scrollConsolesToBottom, 100);
    });

    collapseDownBtn.addEventListener('click', function() {
        // Collapse downward (minimize main console)
        mainConsole.style.flexBasis = '0%';
        rightDivider.style.top = '0%';
        // Scroll consoles to bottom after collapsing with a delay
        setTimeout(scrollConsolesToBottom, 100);
    });

    function resizeDividers(e) {
        if (activeResizer === 'horizontal') {
            // Resize horizontal divider (left-right)
            const container = document.querySelector('.top-section');
            const containerRect = container.getBoundingClientRect();
            let percentage = ((e.clientX - containerRect.left) / containerRect.width) * 100;

            // Limit the minimum and maximum sizes
            percentage = Math.max(20, Math.min(80, percentage));

            // Update the flex-basis of the chess tabs container
            chessTabsContainer.style.flexBasis = `${percentage}%`;

            // Update the divider position
            topDivider.style.left = `${percentage}%`;
        } else if (activeResizer === 'vertical') {
            // Resize vertical divider (top-bottom)
            const container = rightContent;
            const containerRect = container.getBoundingClientRect();
            let percentage = ((e.clientY - containerRect.top) / containerRect.height) * 100;

            // Limit the minimum and maximum sizes
            percentage = Math.max(20, Math.min(80, percentage));

            // Update the flex-basis of the main console
            mainConsole.style.flexBasis = `${percentage}%`;

            // Update the divider position
            rightDivider.style.top = `${percentage}%`;
        }

        // During active resize, we'll just scroll the main text area directly
        // This is more efficient than scrolling all text areas during rapid resize events
        if (mainTextArea) {
            mainTextArea.scrollTop = mainTextArea.scrollHeight;
        }
    }

    // Helper function to scroll all text areas to the bottom
    function scrollConsolesToBottom() {
        // Use setTimeout to ensure this runs after the browser has updated the layout
        setTimeout(() => {
            console.log('Scrolling consoles to bottom');

            // Scroll main console to bottom
            if (mainTextArea) {
                console.log('Main text area scrollHeight:', mainTextArea.scrollHeight);
                mainTextArea.scrollTop = mainTextArea.scrollHeight;
            }

            // Scroll all tab text areas to bottom
            const tabTextAreas = document.querySelectorAll('.tab-text-area');
            console.log('Found', tabTextAreas.length, 'tab text areas');

            tabTextAreas.forEach(textArea => {
                console.log('Tab text area scrollHeight:', textArea.scrollHeight);
                textArea.scrollTop = textArea.scrollHeight;
            });

            // Also try to scroll any visible active tab content
            const activeTabContents = document.querySelectorAll('.tab-content-active');
            activeTabContents.forEach(tabContent => {
                const textAreas = tabContent.querySelectorAll('textarea');
                textAreas.forEach(textArea => {
                    console.log('Active tab textarea scrollHeight:', textArea.scrollHeight);
                    textArea.scrollTop = textArea.scrollHeight;
                });
            });
        }, 50); // Small delay to ensure DOM updates have completed
    }

    function stopResize() {
        activeResizer = null;
        document.removeEventListener('mousemove', resizeDividers);
        document.removeEventListener('mouseup', stopResize);

        // Scroll consoles to bottom after resize is complete
        // Use a slightly longer delay to ensure layout has fully updated
        setTimeout(scrollConsolesToBottom, 100);

        // Also try a direct approach for the main text area
        setTimeout(() => {
            if (mainTextArea) {
                mainTextArea.scrollTop = mainTextArea.scrollHeight;
            }
        }, 200);
    }

    // Global preferences object to store user preferences in memory
    let preferences = {
        // Chess board preferences
        pieceSet: 'alpha',
        lightSquareColor: '#e8e0c8',
        darkSquareColor: '#AB8B69',

        // FICS preferences
        ficsUsername: '',
        ficsPassword: '',
        autoLogin: true,

        // Tabs preferences
        channelTellsToTabs: true,
        directTellsToTabs: true,
        gameTellsToTabs: true,
        autoSwitchToNewTabs: true,
        flashTabsOnActivity: true
    };

    // Default preferences
    let currentPieceSet = 'alpha';
    let lightSquareColor = '#e8e0c8';
    let darkSquareColor = '#AB8B69';

    // Load preferences from local storage
    function loadPreferences() {
        if (localStorage.getItem('chessPreferences')) {
            // Load preferences from local storage into the preferences object
            const storedPrefs = JSON.parse(localStorage.getItem('chessPreferences'));

            // Update the preferences object with stored values
            Object.assign(preferences, storedPrefs);

            console.log('Preferences loaded:', preferences);

            // Update global variables used elsewhere in the code
            currentPieceSet = preferences.pieceSet;
            lightSquareColor = preferences.lightSquareColor;
            darkSquareColor = preferences.darkSquareColor;

            // Update UI to reflect loaded preferences

            // Chess board UI
            document.getElementById('prefPieceSet').value = preferences.pieceSet;
            document.getElementById('prefLightSquare').value = preferences.lightSquareColor;
            document.getElementById('prefDarkSquare').value = preferences.darkSquareColor;
            document.getElementById('lightSquarePreview').style.backgroundColor = preferences.lightSquareColor;
            document.getElementById('darkSquarePreview').style.backgroundColor = preferences.darkSquareColor;

            // FICS preferences UI
            document.getElementById('prefFicsUsername').value = preferences.ficsUsername || '';

            if (preferences.ficsPassword) {
                try {
                    // Simple decoding of password
                    document.getElementById('prefFicsPassword').value = atob(preferences.ficsPassword);
                } catch (e) {
                    console.error('Error decoding password:', e);
                }
            }

            document.getElementById('prefAutoLogin').checked = preferences.autoLogin;

            // Tabs preferences UI
            document.getElementById('prefChannelTellsToTabs').checked = preferences.channelTellsToTabs;
            document.getElementById('prefDirectTellsToTabs').checked = preferences.directTellsToTabs;
            document.getElementById('prefGameTellsToTabs').checked = preferences.gameTellsToTabs;
            document.getElementById('prefAutoSwitchToNewTabs').checked = preferences.autoSwitchToNewTabs;
            document.getElementById('prefFlashTabsOnActivity').checked = preferences.flashTabsOnActivity;

            // Initialize the piece set preview
            updatePieceSetPreview(preferences.pieceSet);

            // Apply preferences to the board
            applyPreferences();
        } else {
            // Initialize with default piece set
            updatePieceSetPreview('alpha');
            console.log('No stored preferences found, using defaults');
        }
    }

    // Save preferences to local storage
    function savePreferences() {
        // Update preferences object with current values from UI

        // Chess board preferences
        preferences.pieceSet = currentPieceSet;
        preferences.lightSquareColor = lightSquareColor;
        preferences.darkSquareColor = darkSquareColor;

        // FICS preferences
        preferences.ficsUsername = document.getElementById('prefFicsUsername').value;
        const rawPassword = document.getElementById('prefFicsPassword').value;
        preferences.ficsPassword = rawPassword ? btoa(rawPassword) : ''; // Simple encoding for password
        preferences.autoLogin = document.getElementById('prefAutoLogin').checked;

        // Tabs preferences
        preferences.channelTellsToTabs = document.getElementById('prefChannelTellsToTabs').checked;
        preferences.directTellsToTabs = document.getElementById('prefDirectTellsToTabs').checked;
        preferences.gameTellsToTabs = document.getElementById('prefGameTellsToTabs').checked;
        preferences.autoSwitchToNewTabs = document.getElementById('prefAutoSwitchToNewTabs').checked;
        preferences.flashTabsOnActivity = document.getElementById('prefFlashTabsOnActivity').checked;

        // Save to local storage
        localStorage.setItem('chessPreferences', JSON.stringify(preferences));

        console.log('Preferences saved:', preferences);
    }

    // Apply preferences to the board
    function applyPreferences() {
        // Update piece set
        if (document.getElementById('chessBoard')) {
            updateBoardFromChessJS();
        }

        // Update square colors
        const lightSquares = document.querySelectorAll('.light-square');
        const darkSquares = document.querySelectorAll('.dark-square');

        lightSquares.forEach(square => {
            square.style.backgroundColor = lightSquareColor;
        });

        darkSquares.forEach(square => {
            square.style.backgroundColor = darkSquareColor;
        });
    }

    mainInput.addEventListener('keypress', (event) => {
        switch (event.key) {
            case "Enter":
              const message = mainInput.value;
              ws.send(filterInvalid(message) + '\n\r');
              mainInput.value = '';
              break;
        }
    });

    function connectWebSocket() {
        ws = new WebSocket(wsUrl);
        ws.addEventListener("message", (event) => {
             if (event.data instanceof Blob) {
               const reader = new FileReader();
               reader.onload = function(e) {
                 var msg = reader.result;
                 // Route the message (which will also check for password prompt)
                 routeMessage(msg);
               };
               reader.readAsText(event.data);
             } else {
               routeMessage(event.data); // Handle text data
             }
           });

        ws.onopen = () => {
            routeMessage('Connected\n');
            if (isAutoLoginEnabled()) {
                isLoggingIn=true;
            }
        };

        ws.onerror = (error) => {
            routeMessage(`Error: ${JSON.stringify(error)}\n`);
            statusDiv.textContent = 'Error';
        };

        ws.onclose = () => {
            routeMessage('Disconnected\n');
            statusDiv.textContent = 'Disconnected';
            ws = null;
            setTimeout(connectWebSocket, 5000);
        };
    }

    // Check if auto-login is enabled
    function isAutoLoginEnabled() {
        // Use the preferences object directly
        return preferences.autoLogin === true &&
               preferences.ficsUsername &&
               preferences.ficsPassword;
    }

    function filterInvalid(msg) {
        var result = '';
        var filtered = "";
        for (var i = 0; i < msg.length; i++) {
           if (msg.charCodeAt(i) >= 32 && msg.charCodeAt(i) <= 126) {
              result += msg.charAt(i);
           } else {
              filtered += msg.charAt(i);
           }
        }
        if (filtered != '') {
            routeMessage('\nFiltered output: ' + filtered);
        }
        return result;
    }

    function inactiveAllTabs() {
        // Hide all chat tab content
        const allTabContents = document.querySelectorAll("#tabset .tab-content");
        for (let i = 0; i < allTabContents.length; i++) {
            allTabContents[i].classList.remove("tab-content-active");
            allTabContents[i].classList.add("tab-content-inactive");

            // Ensure the display property is set to none
            allTabContents[i].style.display = 'none';
        }

        const allTabs = document.querySelectorAll("#tabs .tab");
        // Remove active class from all chat tabs
        for (let i = 0; i < allTabs.length; i++) {
            allTabs[i].classList.remove("tab-active");
            allTabs[i].classList.add("tab-inactive");
        }
    }

    function inactiveAllChessTabs() {
        // Hide all chess tab content
        const activeTabContents = document.querySelectorAll("#chessTabset .tab-content");
        for (let i = 0; i < activeTabContents.length; i++) {
            activeTabContents[i].classList.remove("tab-content-active");
            activeTabContents[i].classList.add("tab-content-inactive");
        }

        const activeTabs = document.querySelectorAll("#chessTabs .tab");
        // Remove active class from all chess tabs
        for (let i = 0; i < activeTabs.length; i++) {
            activeTabs[i].classList.remove("tab-active");
            activeTabs[i].classList.add("tab-inactive");
        }
    }

    // Function to check if there are any tabs open and adjust the layout
    function updateTabsVisibility() {
        const tabElements = document.querySelectorAll('#tabs .tab');
        const rightDivider = document.getElementById('rightDivider');
        const mainConsole = document.querySelector('.main-console');
        const chatTabsContainer = document.querySelector('.chat-tabs-container');
        const rightContent = document.querySelector('.right-content');

        if (tabElements.length > 0) {
            // Show the divider and set 50/50 split when tabs exist
            rightDivider.style.display = 'block';
            mainConsole.style.flex = '0 0 50%';
            chatTabsContainer.style.display = 'flex';

            // Explicitly set the divider position to 50%
            rightDivider.style.top = '50%';

            // Force a layout recalculation to ensure the divider is positioned correctly
            setTimeout(() => {
                // Trigger a resize event to ensure all elements are properly positioned
                window.dispatchEvent(new Event('resize'));
            }, 0);
        } else {
            // Hide the divider and give full height to main console when no tabs
            rightDivider.style.display = 'none';
            mainConsole.style.flex = '1';
            chatTabsContainer.style.display = 'none';
        }
    }

    function createTab(type, name) {
        const id = type + "-" + name;

        // Make all existing tabs inactive
        inactiveAllTabs();

        // Create the new tab
        const tabDiv = document.createElement('div');
        tabDiv.id= 'tab-' + id;
        tabDiv.classList.add("tab-active");
        tabDiv.classList.add("tab");
        tabs.append(tabDiv);

        const tabLabel = document.createElement('span');
        tabLabel.id= 'tab-label-' + id;
        tabLabel.innerHTML=type + " " + name + "&nbsp";
        tabLabel.addEventListener('click', function(event) {
           const id = event.target.id.replace("tab-label-","");
           const tab = document.getElementById("tab-" + id);
           if (tab) {
               // Make all console tabs inactive first, don't affect chess tabs
               inactiveAllTabs();

               // Make this tab active
               tab.classList.remove('tab-inactive');
               tab.classList.add('tab-active');

               // Show this tab's content
               const tabContent = document.getElementById("tab-content-" + id);
               tabContent.classList.remove('tab-content-inactive');
               tabContent.classList.add('tab-content-active');
               tabContent.style.display = 'flex'; // Ensure it's visible
           }
        });
        tabDiv.append(tabLabel);

        const tabDivSpan = document.createElement('span');
        tabDivSpan.innerHTML = "x";
        tabDivSpan.classList.add('close-btn');
        tabDivSpan.addEventListener('click', function(event) {
            closeTab(id);
        });
        tabDiv.append(tabDivSpan);

        const tabContent = document.createElement('div');
        tabContent.id='tab-content-' + id;
        tabContent.classList.add('tab-content');
        tabContent.classList.add('tab-content-active');
        tabContent.classList.add('grid-container');
        tabContent.style.display = 'flex'; // Ensure it's visible initially
        tabContent.style.flexDirection = 'column';
        tabContent.style.height = '100%';
        tabSet.append(tabContent);

        // Make all other tab contents inactive and hidden
        const otherTabContents = document.querySelectorAll('#tabset .tab-content:not(#tab-content-' + id + ')');
        for (let i = 0; i < otherTabContents.length; i++) {
            otherTabContents[i].classList.remove('tab-content-active');
            otherTabContents[i].classList.add('tab-content-inactive');
            otherTabContents[i].style.display = 'none';
        }

        // Text area container with flex: 1 to fill available space
        const row1 = document.createElement('div');
        row1.classList.add('grid-row');
        row1.style.flex = '1';
        row1.style.display = 'flex';
        row1.style.flexDirection = 'column';
        row1.style.minHeight= '100px';
        row1.style.maxHeight= 'calc(100% - 15px)';

        // Input row with fixed height
        const row2 = document.createElement('div');
        row2.classList.add('grid-row');
        row2.style.setProperty("grid-template-columns","auto 1fr");
        row2.style.marginTop = '10px';

        var textArea = document.createElement('textarea');
        textArea.id='textarea-' + id;
        textArea.classList.add('tab-text-area');
        textArea.readOnly=true;
        textArea.style.flex = '1';
        textArea.style.minHeight = '100px';

        var tabInputLabel = document.createElement('span');
        tabInputLabel.classList.add('tab-input-label');
        tabInputLabel.classList.add('inputLabel');
        tabInputLabel.innerHTML = "tell " + name;

        var input = document.createElement('input');
        input.classList.add('input-' + id);
        input.classList.add('tab-Input');
        input.id='input-' + id;
        input.style.height = '24px';

        input.addEventListener('keypress', (event) => {
            switch (event.key) {
                case "Enter":
                  const message = input.value;
                  ws.send("tell " + name + " " + filterInvalid(message) + '\n\r');
                  input.value = '';
                  break;
            }
        });

        row1.append(textArea);
        row2.append(tabInputLabel);
        row2.append(input);
        tabContent.append(row1);
        tabContent.append(row2);

        // Update tabs visibility after creating a new tab
        updateTabsVisibility();
    }

    function createGameTab(opponent) {
        const id = "game-" + opponent;
        gameTabId = id;
        // Only make chess tabs inactive, don't affect console tabs
        inactiveAllChessTabs();
        const tabDiv = document.createElement('div');
        tabDiv.id = 'tab-' + id;
        tabDiv.classList.add("tab-active");
        tabDiv.classList.add("tab");
        chessTabs.append(tabDiv);

        const tabLabel = document.createElement('span');
        tabLabel.id = 'tab-label-' + id;

        // Different label for practice board vs actual games
        if (opponent === "Practice") {
            tabLabel.innerHTML = "Practice Board" + "&nbsp";
        } else {
            tabLabel.innerHTML = "Game vs " + opponent + "&nbsp";
        }
        tabLabel.addEventListener('click', function(event) {
            const id = event.target.id.replace("tab-label-","");
            const tab = document.getElementById("tab-" + id);
            if (tab) {
                // Only make chess tabs inactive, don't affect console tabs
                inactiveAllChessTabs();
                tab.classList.remove('tab-inactive');
                tab.classList.add('tab-active');
                const tabContent = document.getElementById("tab-content-" + id);
                tabContent.classList.remove('tab-content-inactive');
                tabContent.classList.add('tab-content-active');
            }
        });
        tabDiv.append(tabLabel);

        const tabDivSpan = document.createElement('span');
        tabDivSpan.innerHTML = "x";
        tabDivSpan.classList.add('close-btn');
        tabDivSpan.addEventListener('click', function(event) {
            closeTab(id);
            gameTabId = null;
        });
        tabDiv.append(tabDivSpan);

        const tabContent = document.createElement('div');
        tabContent.id = 'tab-content-' + id;
        tabContent.classList.add('tab-content');
        tabContent.classList.add('tab-content-active');
        tabContent.classList.add('grid-container');
        chessTabSet.append(tabContent);

        // Chess board and controls container
        const boardAndControlsContainer = document.createElement('div');
        boardAndControlsContainer.classList.add('grid-row');
        boardAndControlsContainer.style.display = 'flex';
        boardAndControlsContainer.style.justifyContent = 'center';
        boardAndControlsContainer.style.alignItems = 'flex-start';
        boardAndControlsContainer.style.gap = '15px';

        // Chess board container
        const boardContainer = document.createElement('div');
        boardContainer.style.flexShrink = '0';
        const board = document.createElement('div');
        board.id = 'chessBoard';
        board.classList.add('chess-board');
        boardContainer.append(board);
        createChessBoard(board);

        // Board controls container (on the right side)
        const boardControlsContainer = document.createElement('div');
        boardControlsContainer.classList.add('board-controls');
        boardControlsContainer.style.display = 'flex';
        boardControlsContainer.style.flexDirection = 'column';
        boardControlsContainer.style.gap = '10px';
        boardControlsContainer.style.padding = '10px';
        boardControlsContainer.style.border = '1px solid #ccc';
        boardControlsContainer.style.borderRadius = '4px';
        boardControlsContainer.style.backgroundColor = '#f5f5f5';

        // Add containers to the main container
        boardAndControlsContainer.append(boardContainer);
        boardAndControlsContainer.append(boardControlsContainer);

        // Game controls
        const controls = document.createElement('div');
        controls.classList.add('grid-row');
        controls.classList.add('game-controls');

        // Different controls for practice board vs actual games
        if (opponent === "Practice") {
            // Create buttons for the board controls container
            const resetBtn = document.createElement('button');
            resetBtn.innerText = 'Reset Board';
            resetBtn.style.padding = '8px 12px';
            resetBtn.style.width = '100%';
            resetBtn.onclick = () => {
                chess.reset();
                updateBoardFromChessJS();
                const status = document.getElementById('gameStatus');
                if (status) {
                    status.innerText = 'Practice board - White to move';
                }
            };

            const flipBtn = document.createElement('button');
            flipBtn.innerText = 'Flip Board';
            flipBtn.style.padding = '8px 12px';
            flipBtn.style.width = '100%';
            flipBtn.onclick = () => {
                myColor = myColor === 'white' ? 'black' : 'white';
                updateBoardFromChessJS();
                const status = document.getElementById('gameStatus');
                if (status) {
                    status.innerText = `Practice board - ${chess.turn() === 'w' ? 'White' : 'Black'} to move`;
                }
            };

            // Add title to the board controls container
            const controlsTitle = document.createElement('div');
            controlsTitle.innerText = 'Board Controls';
            controlsTitle.style.fontWeight = 'bold';
            controlsTitle.style.marginBottom = '10px';
            controlsTitle.style.textAlign = 'center';

            // Add practice board control buttons to the board controls container
            boardControlsContainer.append(controlsTitle);
            boardControlsContainer.append(resetBtn);
            boardControlsContainer.append(flipBtn);
        } else {
            // Create buttons for the board controls container
            const startBtn = document.createElement('button');
            startBtn.innerText = 'Start Game';
            startBtn.style.padding = '8px 12px';
            startBtn.style.width = '100%';
            startBtn.onclick = () => ws.send(`match ${opponent}\n\r`);

            const drawBtn = document.createElement('button');
            drawBtn.innerText = 'Offer Draw';
            drawBtn.style.padding = '8px 12px';
            drawBtn.style.width = '100%';
            drawBtn.onclick = () => ws.send('draw\n\r');

            const resignBtn = document.createElement('button');
            resignBtn.innerText = 'Resign';
            resignBtn.style.padding = '8px 12px';
            resignBtn.style.width = '100%';
            resignBtn.onclick = () => ws.send('resign\n\r');

            // Add title to the board controls container
            const controlsTitle = document.createElement('div');
            controlsTitle.innerText = 'Game Controls';
            controlsTitle.style.fontWeight = 'bold';
            controlsTitle.style.marginBottom = '10px';
            controlsTitle.style.textAlign = 'center';

            // Add game control buttons to the board controls container
            boardControlsContainer.append(controlsTitle);
            boardControlsContainer.append(startBtn);
            boardControlsContainer.append(drawBtn);
            boardControlsContainer.append(resignBtn);
        }

        // Game status
        const status = document.createElement('div');
        status.classList.add('grid-row');
        status.classList.add('game-status');
        status.id = 'gameStatus';
        status.innerText = 'Game not started';

        // No chat area for game
        tabContent.append(boardAndControlsContainer);
        tabContent.append(status);
    }

    function closeTab(typeAndName) {
        const tab = document.getElementById('tab-' + typeAndName);
        const content = document.getElementById('tab-content-' + typeAndName);
        if (!tab || !content) return;

        const tabsArray = Array.from(document.querySelectorAll("#tabs .tab"));
        const currentIndex = tabsArray.indexOf(tab);
        const isActive = tab.classList.contains("tab-active");

        // Remove tab and content
        tab.remove();
        content.remove();

        // If the closed tab was active, select another tab
        if (isActive) {
            const remainingTabs = document.querySelectorAll("#tabs .tab");
            if (remainingTabs.length > 0) {
                let nextTabIndex = currentIndex < remainingTabs.length ? currentIndex : currentIndex - 1;
                if (nextTabIndex < 0) nextTabIndex = 0;
                const nextTabId = remainingTabs[nextTabIndex].id.replace('tab-','');
                const nextTab = document.getElementById('tab-' + nextTabId);
                nextTab.classList.remove("tab-inactive");
                nextTab.classList.add("tab-active");
                const nextTabContent = document.getElementById('tab-content-' + nextTabId);
                nextTabContent.classList.add("tab-content-active");
                nextTabContent.classList.remove("tab-content-inactive");
            }
        }

        // Update tabs visibility after closing a tab
        updateTabsVisibility();
    }

    function routeMessage(msg) {
        msg = msg.replaceAll("\n\r","\n");
        if (!msg.endsWith("\n")) {
            msg += "\n";
        }
        if (msg.startsWith("\n")) {
            msg = msg.substring(1,msg.length);
        }

        if (isLoggingIn && preferences.autoLogin && msg.toLowerCase().includes('login: ')) {
            ws.send(preferences.ficsUsername + '\n\r');
            console.log('Sent username');
        }

        // Check for password prompt during auto-login
        if (isLoggingIn && preferences.autoLogin && msg.toLowerCase().includes('password: ')) {
            try {
                // Decode the password before sending
                const decodedPassword = atob(preferences.ficsPassword);
                ws.send(decodedPassword + '\n\r');
                console.log('Sent decoded password');
            } catch (e) {
                console.error('Error decoding password:', e);
                // Add error message directly to main text area
                mainTextArea.value += 'Error decoding password: ' + e.message + '\n';
                mainTextArea.scrollTop = mainTextArea.scrollHeight;
            }
            isLoggingIn = false;
        }

        // Check for Style 12 board representation
        if (msg.includes('<12>')) {
            // Don't display Style 12 messages in the console
            // Extract game information from Style 12
            const style12Regex = /<12>\s+(.*)\s+(.*)\s+(.*)\s+(.*)\s+(.*)\s+(.*)\s+(.*)\s+(.*)\s+([WB])\s+(-?\d+)\s+(\d+)\s+(\d+)\s+(\d+)\s+(\d+)\s+(\d+)\s+(\d+)/;
            const match = msg.match(style12Regex);

            if (match) {
                // If we don't have a game tab yet, create one
                if (!gameTabId) {
                    // Try to extract opponent name from the message
                    // For simplicity, we'll use "Opponent" as a placeholder
                    // In a real implementation, you'd extract this from other FICS messages
                    createGameTab("Opponent");
                }

                // Update the chess board with the Style 12 data
                updateChessBoard(msg);

                // Skip displaying this message in the main console
                return;
            }
        }

        // Check for game start messages
        if (msg.includes('Creating: ') && msg.includes('vs.')) {
            const match = msg.match(/Creating: .* (\w+) vs\. (\w+)/);
            if (match && match.length >= 3) {
                const opponent = match[2]; // Assuming the second player is the opponent
                createGameTab(opponent);
                console.log("Created game tab from game creation message");
            }
        }

        // Get tab routing preferences from the preferences object
        const channelTellsToTabs = preferences.channelTellsToTabs;
        const directTellsToTabs = preferences.directTellsToTabs;
        const gameTellsToTabs = preferences.gameTellsToTabs;
        const autoSwitchToNewTabs = preferences.autoSwitchToNewTabs;

        var isMain = true;
        var name = null;
        var type = null;

        // Handle channel tells
        if (/^[a-zA-Z0-9]+\([0-9]+\)\:\s/.test(msg)) { //channel tell.
            type = "channel";
            name = msg.split(/[()]/)[1].trim();

            if (channelTellsToTabs) {
                var tabId = type + "-" + name;
                var tab = document.getElementById("tab-" + tabId);
                if (!tab) {
                    createTab(type, name);

                    // Auto-switch to new tab if enabled
                    if (autoSwitchToNewTabs) {
                        const tabLabel = document.getElementById("tab-label-" + tabId);
                        if (tabLabel) {
                            tabLabel.click();
                        }
                    }
                }
                isMain = false;
                var textArea = document.getElementById("textarea-" + tabId);
                const autoScroll = textArea.scrollHeight - textArea.scrollTop <= textArea.clientHeight;
                textArea.value += msg;
                if (autoScroll)
                    textArea.scrollTop = textArea.scrollHeight;
            }
        }

        // Handle direct tells (to be implemented)
        // if (msg.match(/^[a-zA-Z0-9]+ tells you:/)) {
        //     // Direct tell handling logic
        // }

        // Handle game tells (to be implemented)
        // if (gameTabId && msg.match(/^[a-zA-Z0-9]+ \(your opponent\) tells you:/)) {
        //     // Game tell handling logic
        // }

        // Always show in main if not routed elsewhere or if routing is disabled
        if (isMain) {
            const autoScroll = mainTextArea.scrollHeight - mainTextArea.scrollTop <= mainTextArea.clientHeight;
            mainTextArea.value += msg;
            if (autoScroll)
                mainTextArea.scrollTop = mainTextArea.scrollHeight;
        }
    }

    // Variables for drag and drop functionality
    let draggedPiece = null;
    let draggedPieceElement = null;
    let startSquare = null;

    function createChessBoard(board) {
        // Create a container for the board and labels
        const boardContainer = document.createElement('div');
        boardContainer.classList.add('chess-board-container');
        boardContainer.style.margin = '0 auto';
        board.parentNode.insertBefore(boardContainer, board);
        boardContainer.appendChild(board);

        board.innerHTML = '';

        // Set explicit dimensions for the board
        board.style.width = '400px';
        board.style.height = '400px';
        board.style.display = 'grid';
        board.style.gridTemplateColumns = 'repeat(8, 1fr)';
        board.style.gridTemplateRows = 'repeat(8, 1fr)';

        // Create the chess squares with embedded rank and file labels
        for (let rank = 8; rank >= 1; rank--) {
            for (let file = 1; file <= 8; file++) {
                const square = document.createElement('div');
                square.classList.add('chess-square');
                square.classList.add((rank + file) % 2 === 0 ? 'light-square' : 'dark-square');
                square.id = `square-${file}-${rank}`;
                square.dataset.file = file;
                square.dataset.rank = rank;
                square.dataset.algebraic = `${String.fromCharCode(96 + file)}${rank}`;

                // Add both click and drag-drop event listeners
                square.addEventListener('click', () => handleSquareClick(file, rank));

                // Add dragover and drop events for the square
                square.addEventListener('dragover', (e) => {
                    e.preventDefault(); // Allow drop
                    if (validMoves.includes(square.dataset.algebraic)) {
                        square.classList.add('valid-move');
                    }
                });

                square.addEventListener('drop', (e) => {
                    e.preventDefault();
                    if (draggedPiece && startSquare) {
                        const targetSquare = square.dataset.algebraic;
                        handleDrop(targetSquare);
                    }
                });

                // Add rank label to rightmost squares
                if (file === 8) {
                    const rankLabel = document.createElement('div');
                    rankLabel.classList.add('rank-label');
                    rankLabel.textContent = rank;
                    rankLabel.style.right = '2px';
                    rankLabel.style.left = 'auto';
                    square.appendChild(rankLabel);
                }

                // Add file label to bottom row squares
                if (rank === 1) {
                    const fileLabel = document.createElement('div');
                    fileLabel.classList.add('file-label');
                    fileLabel.textContent = String.fromCharCode(96 + file);

                    // Move the h-file label to the left to avoid the resize handle
                    if (file === 8) {
                        fileLabel.style.right = '15px';
                    }

                    square.appendChild(fileLabel);
                }

                // Add a container for the chess piece
                const pieceElement = document.createElement('div');
                pieceElement.classList.add('chess-piece');
                // Set initial font size based on board dimensions
                const initialSquareSize = 400 / 8; // Initial board width divided by 8
                pieceElement.style.fontSize = Math.max(Math.floor(initialSquareSize * 0.8), 24) + 'px';
                square.appendChild(pieceElement);

                // Set dimensions for each square based on board size
                square.style.width = '100%';
                square.style.height = '100%';
                square.style.display = 'flex';
                square.style.justifyContent = 'center';
                square.style.alignItems = 'center';
                square.style.fontSize = '36px';
                square.style.position = 'relative';

                board.appendChild(square);
            }
        }

        // Add resize observer to update labels when board is resized
        const resizeObserver = new ResizeObserver(entries => {
            for (let entry of entries) {
                const width = entry.contentRect.width;
                const height = entry.contentRect.height;

                // Ensure the board remains square by setting height equal to width
                if (width !== height) {
                    // Use the smaller dimension to ensure it fits in the container
                    const size = Math.min(width, height);
                    board.style.width = size + 'px';
                    board.style.height = size + 'px';
                }

                const squareSize = width / 8; // Since width and height are equal, use width

                // Update font size of rank and file labels based on square size
                const rankLabels = board.querySelectorAll('.rank-label');
                const fileLabels = board.querySelectorAll('.file-label');
                const labelFontSize = Math.max(Math.floor(squareSize * 0.2), 8) + 'px';

                rankLabels.forEach(label => {
                    label.style.fontSize = labelFontSize;
                    // Only show rank labels on the rightmost column
                    const squareElement = label.parentElement;
                    const file = parseInt(squareElement.dataset.file);
                    label.style.display = file === 8 ? 'block' : 'none';

                    // Force rank labels to stay on the right side
                    label.style.right = '2px';
                    label.style.left = 'auto';
                    // Use setAttribute to ensure the style is applied
                    label.setAttribute('style', label.getAttribute('style') + '; left: auto !important; right: 2px;');
                });

                fileLabels.forEach(label => {
                    label.style.fontSize = labelFontSize;
                    // Only show file labels on the bottom row
                    const squareElement = label.parentElement;
                    const rank = parseInt(squareElement.dataset.rank);
                    const file = parseInt(squareElement.dataset.file);
                    label.style.display = rank === 1 ? 'block' : 'none';

                    // Ensure file labels are at the bottom right
                    label.style.bottom = '2px';
                    label.style.right = '2px';

                    // Special case for h-file to avoid resize handle
                    if (file === 8) {
                        label.style.right = '15px';
                    }
                });

                // Update the font size of pieces based on square size
                const pieceElements = board.querySelectorAll('.chess-piece');
                // Use a larger proportion of the square for the piece size
                const fontSize = Math.max(Math.floor(squareSize * 0.8), 24) + 'px';
                pieceElements.forEach(piece => {
                    piece.style.fontSize = fontSize;
                });

                // Also update any existing pieces in the updateBoardFromChessJS function
                if (typeof updatePieceSizes === 'function') {
                    updatePieceSizes(squareSize);
                }
            }
        });

        // Add a resize handle to make it more obvious the board can be resized
        const resizeHandle = document.createElement('div');
        resizeHandle.classList.add('resize-handle');
        board.appendChild(resizeHandle);

        // Add a manual resize handler to ensure square aspect ratio
        board.addEventListener('mousedown', (e) => {
            if (e.offsetX > board.offsetWidth - 20 && e.offsetY > board.offsetHeight - 20) {
                // Near the resize handle
                const startX = e.clientX;
                const startY = e.clientY;
                const startWidth = board.offsetWidth;

                const onMouseMove = (moveEvent) => {
                    const newWidth = startWidth + (moveEvent.clientX - startX);
                    // Set both width and height to the same value to maintain square aspect ratio
                    board.style.width = newWidth + 'px';
                    board.style.height = newWidth + 'px';
                    moveEvent.preventDefault();
                };

                const onMouseUp = () => {
                    document.removeEventListener('mousemove', onMouseMove);
                    document.removeEventListener('mouseup', onMouseUp);
                };

                document.addEventListener('mousemove', onMouseMove);
                document.addEventListener('mouseup', onMouseUp);
            }
        });

        resizeObserver.observe(board);

        // Initialize with starting position
        chess.reset();
        updateBoardFromChessJS();
    }


    function handleSquareClick(file, rank) {
        const square = `${String.fromCharCode(96 + file)}${rank}`;
        const squareDiv = document.getElementById(`square-${file}-${rank}`);

        // Check if this is a practice board or a real game
        const isPracticeBoard = gameTabId && gameTabId === "game-Practice";

        // For real games, check if it's the player's turn
        if (!isPracticeBoard) {
            const playerColor = myColor === 'white' ? 'w' : 'b';
            if (chess.turn() !== playerColor) {
                // If it's not the player's turn, just show a message
                const status = document.getElementById('gameStatus');
                if (status) {
                    status.innerText = "It's not your turn";
                    setTimeout(() => {
                        status.innerText = chess.turn() === 'w' ? 'White to move' : 'Black to move';
                    }, 1500);
                }
                return;
            }
        }

        if (selectedSquare === square) {
            // Deselect if clicked again
            selectedSquare = null;
            validMoves = [];
            updateBoardFromChessJS();
        } else if (validMoves.includes(square)) {
            // Check if this is a pawn promotion move
            const piece = chess.get(selectedSquare);
            const isPromotion = piece &&
                               piece.type === 'p' &&
                               ((piece.color === 'w' && rank === 8) ||
                                (piece.color === 'b' && rank === 1));

            if (isPromotion) {
                // Ask user what piece to promote to
                const promotionPiece = prompt('Promote pawn to: (q)ueen, (r)ook, (b)ishop, (n)knight', 'q');
                const validPromotions = ['q', 'r', 'b', 'n'];
                const promotion = validPromotions.includes(promotionPiece) ? promotionPiece : 'q';

                // Make move with promotion
                const move = {
                    from: selectedSquare,
                    to: square,
                    promotion: promotion
                };
                chess.move(move);
                ws.send(`move ${move.from}${move.to}=${promotion}\n\r`);
            } else {
                // Make regular move
                const move = {
                    from: selectedSquare,
                    to: square
                };
                chess.move(move);
                ws.send(`move ${move.from}${move.to}\n\r`);
            }

            // Reset selection
            selectedSquare = null;
            validMoves = [];
            updateBoardFromChessJS();
        } else {
            // Check if the square has a piece
            const piece = chess.get(square);
            if (piece) {
                // For practice board, allow selecting any piece
                // For real games, only allow selecting pieces of the player's color
                const playerColor = myColor === 'white' ? 'w' : 'b';
                const isPracticeBoard = gameTabId && gameTabId === "game-Practice";

                if (isPracticeBoard || piece.color === playerColor) {
                    // Select new square and highlight valid moves
                    selectedSquare = square;
                    validMoves = chess.moves({ square: square, verbose: true }).map(move => move.to);
                    updateBoardFromChessJS();
                }
            }
        }
    }

    // Function to update piece sizes based on square size
    function updatePieceSizes(squareSize) {
        const pieceElements = document.querySelectorAll('.chess-piece');
        // For Material Symbols font, we need to adjust the size to fill the square properly
        const fontSize = Math.max(Math.floor(squareSize * 0.8), 24) + 'px';
        pieceElements.forEach(piece => {
            piece.style.fontSize = fontSize;
        });
    }

    function updateBoardFromChessJS() {
        // Get the board dimensions to scale pieces appropriately
        const board = document.getElementById('chessBoard');
        const squareSize = board ? board.clientWidth / 8 : 50;
        const fontSize = Math.max(Math.floor(squareSize * 0.8), 24) + 'px';
        const labelFontSize = Math.max(Math.floor(squareSize * 0.2), 8) + 'px';

        for (let rank = 8; rank >= 1; rank--) {
            for (let file = 1; file <= 8; file++) {
                const square = `${String.fromCharCode(96 + file)}${rank}`;
                const squareDiv = document.getElementById(`square-${file}-${rank}`);
                if (!squareDiv) continue;

                // Update font size based on board size
                squareDiv.style.fontSize = fontSize;

                const piece = chess.get(square);
                let pieceSymbol = '';

                if (piece) {
                    // Use SVG images for chess pieces
                    const pieceColor = piece.color === 'w' ? 'w' : 'b';
                    const pieceType = piece.type.toUpperCase();
                    pieceSymbol = `<img src="pieces/${currentPieceSet}/${pieceColor}${pieceType}.svg" alt="${pieceColor}${pieceType}" />`;
                }

                // Check if we need to create or update the rank and file labels
                let rankLabel = squareDiv.querySelector('.rank-label');
                let fileLabel = squareDiv.querySelector('.file-label');

                // If labels don't exist, create them
                if (!rankLabel) {
                    rankLabel = document.createElement('div');
                    rankLabel.classList.add('rank-label');
                    rankLabel.textContent = rank;
                    squareDiv.appendChild(rankLabel);
                }

                if (!fileLabel) {
                    fileLabel = document.createElement('div');
                    fileLabel.classList.add('file-label');
                    fileLabel.textContent = String.fromCharCode(96 + file);
                    squareDiv.appendChild(fileLabel);
                }

                // Update label visibility and position
                rankLabel.style.fontSize = labelFontSize;
                rankLabel.style.display = file === 8 ? 'block' : 'none';

                // Force rank labels to stay on the right side
                rankLabel.style.left = 'auto !important';
                rankLabel.style.right = '2px';
                rankLabel.setAttribute('style', rankLabel.getAttribute('style') + '; left: auto !important;');

                fileLabel.style.fontSize = labelFontSize;
                fileLabel.style.display = rank === 1 ? 'block' : 'none';
                fileLabel.style.bottom = '2px'; // Ensure it's always at the bottom
                fileLabel.style.right = '2px'; // Default position on the right

                // Move the h-file label to the left to avoid the resize handle
                if (rank === 1 && file === 8) {
                    fileLabel.style.right = '15px';
                }

                // Create a piece element or update existing one
                let pieceElement = squareDiv.querySelector('.chess-piece');
                if (!pieceElement) {
                    pieceElement = document.createElement('div');
                    pieceElement.classList.add('chess-piece');
                    squareDiv.appendChild(pieceElement);
                }

                // Clear any previous event listeners
                const newPieceElement = pieceElement.cloneNode(false);
                if (pieceElement.parentNode) {
                    pieceElement.parentNode.replaceChild(newPieceElement, pieceElement);
                }
                pieceElement = newPieceElement;
                squareDiv.appendChild(pieceElement);

                pieceElement.innerHTML = pieceSymbol;
                pieceElement.style.fontSize = Math.max(Math.floor(squareSize * 0.8), 24) + 'px';

                // Add drag events to pieces
                if (piece) {
                    const playerColor = myColor === 'white' ? 'w' : 'b';

                    // Only allow dragging player's own pieces and only on their turn
                    if (piece.color === playerColor && chess.turn() === playerColor) {
                        pieceElement.setAttribute('draggable', 'true');

                        pieceElement.addEventListener('dragstart', (e) => {
                            // Store the piece and starting square
                            draggedPiece = piece;
                            draggedPieceElement = pieceElement;
                            startSquare = square;

                            // Highlight valid moves
                            validMoves = chess.moves({ square: square, verbose: true }).map(move => move.to);
                            updateBoardHighlights();

                            // Add dragging class for styling
                            setTimeout(() => {
                                pieceElement.classList.add('dragging');
                            }, 0);
                        });

                        pieceElement.addEventListener('dragend', () => {
                            // Clean up after dragging ends
                            pieceElement.classList.remove('dragging');

                            // Reset if the piece wasn't dropped on a valid square
                            if (draggedPiece) {
                                draggedPiece = null;
                                draggedPieceElement = null;
                                startSquare = null;
                                validMoves = [];
                                updateBoardHighlights();
                            }
                        });
                    } else {
                        pieceElement.setAttribute('draggable', 'false');
                    }
                }

                // Remove any previous children that aren't labels or the piece element
                Array.from(squareDiv.childNodes).forEach(node => {
                    if (node !== rankLabel && node !== fileLabel && node !== pieceElement && node.nodeType === Node.TEXT_NODE) {
                        squareDiv.removeChild(node);
                    }
                });

                // Highlighting is now handled by updateBoardHighlights()

                // Set the piece image
                if (pieceSymbol) {
                    pieceElement.innerHTML = pieceSymbol;
                } else {
                    pieceElement.innerHTML = '';
                }
            }
        }
        // Update board highlights
        updateBoardHighlights();

        // Update game status
        const status = document.getElementById('gameStatus');
        if (status) {
            status.innerText = chess.game_over() ? 'Game Over' : chess.turn() === 'w' ? 'White to move' : 'Black to move';
            if (chess.in_checkmate()) status.innerText += ': Checkmate';
            else if (chess.in_draw()) status.innerText += ': Draw';
        }
    }

    function updateChessBoard(style12Message) {
        // Parse Style 12 message to update chess.js position
        const lines = style12Message.split('\n');
        const boardLineIndex = lines.findIndex(line => line.trim().startsWith('<12>'));

        if (boardLineIndex !== -1) {
            const boardLine = lines[boardLineIndex].trim();

            // Style 12 format: <12> [8 rows of board] [turn W/B] [other data...]
            const parts = boardLine.split(' ');

            if (parts.length >= 10) { // At least <12> + 8 rows + turn
                try {
                    // Extract the 8 rows of the board (parts[1] through parts[8])
                    const boardRows = parts.slice(1, 9);

                    // Convert Style 12 board representation to FEN
                    let fen = '';
                    for (let i = 0; i < 8; i++) {
                        let row = boardRows[i];
                        let emptyCount = 0;
                        let fenRow = '';

                        for (let j = 0; j < row.length; j++) {
                            const char = row.charAt(j);
                            if (char === '-') {
                                emptyCount++;
                            } else {
                                if (emptyCount > 0) {
                                    fenRow += emptyCount;
                                    emptyCount = 0;
                                }

                                // Convert FICS piece notation to FEN
                                // In FICS Style12: P=white pawn, p=black pawn, etc.
                                // In FEN: P=white pawn, p=black pawn, etc.
                                // So we can use the character directly
                                fenRow += char;
                            }
                        }

                        if (emptyCount > 0) {
                            fenRow += emptyCount;
                        }

                        fen += fenRow + (i < 7 ? '/' : '');
                    }

                    // Add turn
                    fen += ' ' + (parts[9] === 'W' ? 'w' : 'b');

                    // Add castling, en passant, halfmove, fullmove (simplified)
                    fen += ' KQkq - 0 1';

                    console.log("Generated FEN:", fen);

                    // Load the position into chess.js
                    try {
                        chess.load(fen);
                        console.log("Chess position loaded successfully");
                        updateBoardFromChessJS();
                    } catch (e) {
                        console.error("Failed to load FEN into chess.js:", e);
                        console.error("Invalid FEN:", fen);
                        // If loading fails, try a different approach or reset to starting position
                        try {
                            // Alternative approach: manually set up the board
                            chess.clear();

                            // Map board positions
                            for (let rank = 0; rank < 8; rank++) {
                                const row = boardRows[rank];
                                for (let file = 0; file < row.length; file++) {
                                    const char = row.charAt(file);
                                    if (char !== '-') {
                                        const square = String.fromCharCode(97 + file) + (8 - rank);
                                        const color = char === char.toUpperCase() ? 'w' : 'b';
                                        const pieceType = char.toLowerCase();
                                        chess.put({ type: pieceType, color: color }, square);
                                    }
                                }
                            }

                            // We can't directly set the turn in chess.js
                            // Instead, we'll create a new position with the correct turn

                            // Get the current position as FEN
                            let fen = chess.fen();
                            // Split the FEN string into its components
                            let fenParts = fen.split(' ');
                            // Set the turn (the 2nd component of the FEN string)
                            fenParts[1] = parts[9] === 'W' ? 'w' : 'b';
                            // Rejoin the FEN string
                            fen = fenParts.join(' ');
                            // Load the updated FEN
                            try {
                                chess.load(fen);
                            } catch (e) {
                                // If there's an error, just log it and continue
                                console.error('Error setting turn:', e);
                            }

                            // Set player color based on Style 12 message
                            // parts[9] is the current turn (W/B)
                            // parts[10] is -1 if it's the player's move, 1 if it's the opponent's move
                            if (parts.length > 10) {
                                const isPlayerMove = parts[10] === '-1';
                                if (parts[9] === 'W') {
                                    // If it's White's turn and it's the player's move, player is White
                                    // If it's White's turn and it's not the player's move, player is Black
                                    myColor = isPlayerMove ? 'white' : 'black';
                                } else {
                                    // If it's Black's turn and it's the player's move, player is Black
                                    // If it's Black's turn and it's not the player's move, player is White
                                    myColor = isPlayerMove ? 'black' : 'white';
                                }
                            }

                            updateBoardFromChessJS();
                        } catch (e2) {
                            // If there's an error, reset the board
                            chess.reset();
                            updateBoardFromChessJS();
                        }
                    }
                } catch (e) {
                    // Silently handle parsing errors
                }
            }
        }
    }

    // Function to update board highlights for selected squares and valid moves
    function updateBoardHighlights() {
        // Update all squares
        for (let rank = 8; rank >= 1; rank--) {
            for (let file = 1; file <= 8; file++) {
                const square = `${String.fromCharCode(96 + file)}${rank}`;
                const squareDiv = document.getElementById(`square-${file}-${rank}`);
                if (!squareDiv) continue;

                // Remove existing highlights
                squareDiv.classList.remove('selected', 'valid-move');

                // Add appropriate highlights
                if (square === selectedSquare || square === startSquare) {
                    squareDiv.classList.add('selected');
                } else if (validMoves.includes(square)) {
                    squareDiv.classList.add('valid-move');
                }
            }
        }
    }

    // Function to handle dropping a piece on a square
    function handleDrop(targetSquare) {
        // Check if the target square is a valid move
        if (validMoves.includes(targetSquare)) {
            // Check if this is a pawn promotion move
            const piece = draggedPiece;
            const rank = parseInt(targetSquare.charAt(1));
            const isPromotion = piece &&
                               piece.type === 'p' &&
                               ((piece.color === 'w' && rank === 8) ||
                                (piece.color === 'b' && rank === 1));

            if (isPromotion) {
                // Ask user what piece to promote to
                const promotionPiece = prompt('Promote pawn to: (q)ueen, (r)ook, (b)ishop, (n)knight', 'q');
                const validPromotions = ['q', 'r', 'b', 'n'];
                const promotion = validPromotions.includes(promotionPiece) ? promotionPiece : 'q';

                // Make move with promotion
                const move = {
                    from: startSquare,
                    to: targetSquare,
                    promotion: promotion
                };
                chess.move(move);
                ws.send(`move ${move.from}${move.to}=${promotion}\n\r`);
            } else {
                // Make regular move
                const move = {
                    from: startSquare,
                    to: targetSquare
                };
                chess.move(move);
                ws.send(`move ${move.from}${move.to}\n\r`);
            }

            // Reset drag state
            draggedPiece = null;
            draggedPieceElement = null;
            startSquare = null;
            selectedSquare = null;
            validMoves = [];

            // Update the board
            updateBoardFromChessJS();
        }
    }

    // Moves are made directly by clicking on the board or by dragging pieces

    // Hamburger menu functionality
    function setupPreferencesMenu() {
        const hamburgerMenu = document.getElementById('hamburgerMenu');
        const preferencesPanel = document.getElementById('preferencesPanel');
        const saveButton = document.getElementById('savePreferences');
        const prefPieceSet = document.getElementById('prefPieceSet');
        const prefLightSquare = document.getElementById('prefLightSquare');
        const prefDarkSquare = document.getElementById('prefDarkSquare');
        const lightSquarePreview = document.getElementById('lightSquarePreview');
        const darkSquarePreview = document.getElementById('darkSquarePreview');
        const prefCategories = document.querySelectorAll('.pref-category');
        const prefContents = document.querySelectorAll('.pref-content');

        // Toggle preferences panel
        hamburgerMenu.addEventListener('click', function() {
            preferencesPanel.classList.toggle('show');
            // Update the piece set preview when opening the panel
            if (preferencesPanel.classList.contains('show')) {
                updatePieceSetPreview(prefPieceSet.value);
            }
        });

        // Close panel when clicking outside
        document.addEventListener('click', function(event) {
            if (!preferencesPanel.contains(event.target) && event.target !== hamburgerMenu) {
                preferencesPanel.classList.remove('show');
            }
        });

        // Category tab switching
        prefCategories.forEach(category => {
            category.addEventListener('click', function() {
                // Remove active class from all categories
                prefCategories.forEach(cat => cat.classList.remove('active'));
                // Add active class to clicked category
                this.classList.add('active');

                // Hide all content sections
                prefContents.forEach(content => content.classList.remove('active'));
                // Show the selected content section
                const categoryName = this.getAttribute('data-category');
                document.getElementById(`pref-${categoryName}`).classList.add('active');
            });
        });

        // Update color previews
        prefLightSquare.addEventListener('input', function() {
            lightSquarePreview.style.backgroundColor = this.value;
        });

        prefDarkSquare.addEventListener('input', function() {
            darkSquarePreview.style.backgroundColor = this.value;
        });

        // Update piece set preview when selection changes
        prefPieceSet.addEventListener('change', function() {
            updatePieceSetPreview(this.value);
        });

        // Save preferences
        saveButton.addEventListener('click', function() {
            currentPieceSet = prefPieceSet.value;
            lightSquareColor = prefLightSquare.value;
            darkSquareColor = prefDarkSquare.value;

            savePreferences();
            applyPreferences();
            preferencesPanel.classList.remove('show');
        });
    }

    // Function to update the piece set preview grid
    function updatePieceSetPreview(pieceSet) {
        const pieceTypes = [
            { id: 'preview-bR', piece: 'bR' },
            { id: 'preview-bN', piece: 'bN' },
            { id: 'preview-bB', piece: 'bB' },
            { id: 'preview-bQ', piece: 'bQ' },
            { id: 'preview-bK', piece: 'bK' },
            { id: 'preview-bP', piece: 'bP' },
            { id: 'preview-wP', piece: 'wP' },
            { id: 'preview-wR', piece: 'wR' },
            { id: 'preview-wN', piece: 'wN' },
            { id: 'preview-wB', piece: 'wB' },
            { id: 'preview-wQ', piece: 'wQ' },
            { id: 'preview-wK', piece: 'wK' }
        ];

        // Update each piece image in the preview grid
        pieceTypes.forEach(item => {
            // Find all elements with this ID (for pawns we have multiple)
            const elements = document.querySelectorAll(`#${item.id}`);
            elements.forEach(element => {
                element.src = `pieces/${pieceSet}/${item.piece}.svg`;
            });
        });
    }

    // Create a default chess tab with starting position
    function createDefaultChessTab() {
        // Create a game tab with "Practice" as the opponent name
        createGameTab("Practice");

        // Reset the chess board to the starting position
        chess.reset();

        // Update the board display
        updateBoardFromChessJS();

        // Update the game status
        const status = document.getElementById('gameStatus');
        if (status) {
            status.innerText = 'Practice board - White to move';
        }
    }

    window.onload = function() {
        connectWebSocket();
        loadPreferences();
        setupPreferencesMenu();

        // Initialize tabs visibility (should hide chat tabs initially)
        updateTabsVisibility();

        // Create a default chess tab with starting position
        setTimeout(createDefaultChessTab, 500); // Small delay to ensure DOM is fully loaded
    };
</script>
</body>
</html>
