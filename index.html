<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simple FICS Interface</title>
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans:wght@400;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Share+Tech+Mono&display=swap" rel="stylesheet">
    <style>
        @font-face {
            font-family: 'Digital';
            src: url('https://db.onlinewebfonts.com/t/8e22783d707ad140bffe18b2a3812529.woff2') format('woff2');
            font-weight: normal;
            font-style: normal;
        }

        body {
          font-family: Arial, sans-serif;
          margin: 20px;
        }
        #title {
          color: blue;
          font-family: Digital, Orbitron, monospace;
          margin-left: 15px;
          text-align: center;
        }
        .grid-container {
          display: grid;
        }
        .grid-row {
          display: grid;
          margin-top: 10px;
        }

        /* Main container layout */
        .main-container {
            display: flex;
            flex-direction: column;
            width: 100%;
            height: calc(100vh - 100px); /* Adjust based on your header size */
        }

        /* Top section with chess tabs and right side content */
        .top-section {
            display: flex;
            width: 100%;
            height: 100%;
            position: relative;
        }

        /* Chess board area on the left */
        .chess-board-area {
            flex: 0 0 50%;
            overflow-y: auto;
            overflow-x: hidden; /* Prevent horizontal scrolling */
            border-right: 1px solid #ccc;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            box-sizing: border-box;
            height: 100%;
            min-width: 0; /* Allow flex item to shrink below content size */
        }

        /* Right side content container */
        .right-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            position: relative;
        }

        /* Main console on the top right */
        .main-console {
            flex: 0 0 60%;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            border-bottom: 1px solid #ccc;
            margin-left: 20px;
        }

        /* Make the grid container fill the main console */
        .main-console .grid-container {
            display: flex;
            flex-direction: column;
            height: 100%;
        }

        /* Chat tabs on the bottom right */
        .chat-tabs-container {
            flex: 1;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        /* Make tab content fill available space */
        .chat-tabs-container .tab-content {
            height: 100%;
            display: flex;
            flex-direction: column;
        }

        /* Ensure tab set takes full width but minimal height */
        .chat-tabs-container #tabset {
            display: flex;
            flex-direction: column;
            height: 100%;
        }

        /* Horizontal resizable divider (between chess tabs and right content) */
        .horizontal-divider {
            width: 10px;
            background-color: #f0f0f0;
            cursor: col-resize;
            border-left: 1px solid #ccc;
            border-right: 1px solid #ccc;
            position: absolute;
            top: 0;
            bottom: 0;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* Divider control buttons container */
        .divider-controls {
            position: absolute;
            display: flex;
            flex-direction: column; /* Stack buttons vertically */
            background-color: transparent; /* Make container transparent */
            z-index: 11;
            left: 4px; /* Shift 4px to the right from center */
            transform: translateX(-50%);
        }

        /* Triangle buttons for collapsing divider */
        .triangle-button {
            width: 8px;
            height: 8px;
            padding: 0;
            background-color: #f0f0f0;
            border: none; /* Remove borders */
            cursor: pointer;
            font-size: 8px; /* Smaller font size */
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.2s;
        }

        .triangle-button:hover {
            background-color: #e0e0e0;
        }

        .triangle-button:active {
            background-color: #d0d0d0;
        }

        /* Vertical resizable divider (between main console and chat tabs) */
        .vertical-divider {
            height: 10px;
            background-color: #f0f0f0;
            cursor: row-resize;
            border-top: 1px solid #ccc;
            border-bottom: 1px solid #ccc;
            position: absolute;
            left: 0;
            right: 0;
            top: 50%; /* Default to 50% */
            transform: translateY(-50%);
            z-index: 10;
            transition: opacity 0.2s ease; /* Smooth transition when showing/hiding */
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* Vertical divider controls */
        .divider-controls.vertical {
            flex-direction: row; /* Horizontal arrangement for vertical divider */
            left: 50%; /* Center horizontally */
            transform: translateX(-50%); /* Center the control precisely */
        }

        /* Ensure buttons on both dividers have the same size */
        .divider-controls.vertical .triangle-button {
            width: 8px; /* Match horizontal divider button width */
            height: 8px; /* Match horizontal divider button height */
            font-size: 8px; /* Match horizontal divider button font size */
        }

        .divider:hover {
            background-color: #ddd;
        }

        /* Tab styles for both sections */
        .chess-tabs .tabset, .chat-tabs-container .tabset {
            width: 100%;
            overflow-x: auto;
            overflow-y: hidden; /* Prevent vertical scrolling */
            white-space: nowrap;
        }

        /* Specific styles for chess tabs */
        .chess-tabs .tabset {
            height: auto; /* Adjust height to content */
        }

        /* Ensure chess tab content doesn't scroll vertically */
        .chess-tabs .tab-content {
            overflow-y: hidden; /* Prevent vertical scrolling */
            overflow-x: auto; /* Allow horizontal scrolling if needed */
        }

        /* Make grid containers fill their parent */
        .chess-tabs .grid-container, .main-console .grid-container, .chat-tabs-container .grid-container {
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        /* Make text areas fill available space */
        .ics-text-area, .tab-text-area {
            flex: 1;
            min-height: 100px;
            width: 100%;
            box-sizing: border-box;
            resize: none; /* Prevent manual resizing */
            background-color: blue;
            color: white;
            font-family: 'Courier New', Courier, Monospace;
            font-size: medium;
            font-weight: bold;
            border-radius: 10px; /* Match chessboard border radius */
            box-shadow: 0 4px 6px rgba(0, 0, 0, .75); /* Match chessboard shadow */
            border: none; /* Remove default border */
            padding: 10px; /* Add some padding for better text display */
        }
        .ics-input {
          vertical-align: top;
          width: 98%; /* Reduced from 100% to prevent running off screen */
          height: 24px; /* Fixed height for the input */
          overflow: hidden;
          font-weight: bold;
          border: none; /* Remove default border */
          padding: 5px 10px;
          background-color: blue;
          color: white;
          border-radius: 10px; /* Match chessboard border radius */
          box-shadow: 0 2px 4px rgba(0, 0, 0, .75); /* Slightly smaller shadow than textarea */
          margin-top: 5px; /* Add some space between textarea and input */
          margin-bottom: 5px; /* Add bottom margin to prevent running off screen */
        }
        .tab-Input {
          vertical-align: top;
          width: 100%;
          overflow: hidden;
          font-weight: bold;
          border: none; /* Remove default border */
          padding: 5px 10px;
          background-color: blue;
          color: white;
          max-height: 18px;
          border-radius: 10px; /* Match chessboard border radius */
          box-shadow: 0 2px 4px rgba(0, 0, 0, .75); /* Slightly smaller shadow than textarea */
          margin-top: 5px; /* Add some space between textarea and input */
        }
        .tab-input-label {
          font-weight: bold;
          color: blue;
          padding-top: 2px;
          padding-bottom: 2px;
          padding-right: 5px;
        }
        .tabset {
            margin: 20px auto;
            width: 100%;
        }
        .tabs {
            display: flex;
        }
        .tab {
            padding: 10px 20px;
            cursor: pointer;
            background: #f1f1f1;
            margin-right: 5px;
            border-radius: 5px 5px 0 0;
            position: relative;
            top: 2px;
        }
        .tab-active {
            background: #fff;
            border: 1px solid #ADD8E6;
            border-bottom: none;
            color: blue;
        }
        .tab-inactive {
        }
        .tab-content {
            padding: 20px;
            background: #fff;
            display: none; /* Hidden by default */
            flex-direction: column; /* For proper layout of children */
            height: 100%; /* Fill available height */
        }
        .tab-content-active {
            display: flex; /* Show as flex when active */
        }
        .tab-content-inactive {
            display: none; /* Hide when inactive */
        }
        .close-btn {
            position: relative;
            top: -5px;
            color: #ff0000;
            cursor: pointer;
            font-weight: bold;
            font-size: small;
        }
        .close-btn:hover {
            color: #cc0000;
        }
        .chess-board-container {
            position: relative;
            margin: 20px auto;
            display: inline-block;
        }

        /* Board menu styles */
        .board-menu-button {
            position: absolute;
            top: 10px;
            right: 10px;
            cursor: pointer;
            z-index: 1000;
            font-size: 24px;
            background: none;
            border: none;
            color: #333;
        }

        .board-menu {
            position: absolute;
            top: 50px; /* Position below the menu button */
            right: 20px; /* Align with the right side of the container */
            background-color: white;
            border: 1px solid #ccc;
            border-radius: 5px;
            padding: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            z-index: 999;
            display: none;
        }

        .board-menu.show {
            display: block;
        }

        .board-menu button {
            display: block;
            width: 100%;
            text-align: left;
            background: none;
            border: none;
            cursor: pointer;
            padding: 8px 10px;
            margin: 2px 0;
            border-radius: 4px;
        }

        .board-menu button:hover {
            background-color: #f0f0f0;
        }

        .board-menu button i {
            font-size: 18px;
            margin-right: 8px;
            vertical-align: middle;
        }
        .chess-board {
            width: 400px;
            height: 400px;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, .75);
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            margin: 0 auto;
            position: relative;
            resize: both;
            overflow: hidden;
            min-width: 200px;
            min-height: 200px;
            max-width: 1500px;
            max-height: 1500px;
            aspect-ratio: 1 / 1; /* Force square aspect ratio */
        }
        .chess-square {
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 36px;
            cursor: pointer;
            position: relative;
        }
        .chess-piece {
            position: absolute;
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100%;
            height: 100%;
            z-index: 1;
            cursor: grab;
        }

        .animated-piece {
            position: absolute;
            z-index: 1000;
            pointer-events: none;
            transition: left 0.225s ease-out, top 0.225s ease-out;
        }

        .chess-piece.dragging {
            position: fixed;
            width: 50px;
            height: 50px;
            pointer-events: none;
            z-index: 1000;
            opacity: 0.8;
            transform: translate(-50%, -50%);
        }
        .chess-piece img {
            width: 95%;
            height: 95%;
            object-fit: contain;
        }
        .light-square {
            background-color: #e8e0c8; /* Default lighter beige color - will be overridden by preferences */
        }
        .dark-square {
            background-color: #AB8B69; /* Default darker brown color - will be overridden by preferences */
        }
        .rank-label {
            position: absolute;
            top: 2px;
            right: 2px;
            left: auto !important; /* Force right alignment */
            font-size: 6px; /* Smaller font size */
            font-weight: bold;
            font-family: "Noto Sans", Sans-Serif;
            opacity: 1.0;
            pointer-events: none;
            z-index: 5;
            padding: 0px 1px;
            border-radius: 2px;
        }
        .file-label {
            position: absolute;
            bottom: 1px;
            left: 1px;
            right: auto;
            font-size: 6px; /* Smaller font size */
            font-weight: bold;
            font-family: "Noto Sans", Sans-Serif;
            opacity: 1.0;
            pointer-events: none;
            z-index: 5;
            padding: 0px 1px;
            border-radius: 2px;
        }

        .resize-handle {
            position: absolute;
            bottom: 0;
            right: 0;
            width: 10px;
            height: 10px;
            cursor: nwse-resize;
            z-index: 10;
            background-color: transparent;
        }

        .selected {
            background-color: rgba(173, 216, 230, 0.7) !important; /* Light blue highlight */
        }
        .valid-move {
            background-color: rgba(144, 238, 144, 0.5) !important; /* Light green highlight */
        }
        .game-controls {
            margin-top: 10px;
        }
        .game-controls button {
            margin-right: 10px;
            padding: 5px 10px;
        }
        .game-status {
            font-weight: bold;
            margin-top: 5px;
            color: blue;
        }

        /* Hamburger Menu Styles */
        .hamburger-menu {
            position: absolute;
            top: 15px;
            left: 10px;
            cursor: pointer;
            z-index: 1000;
            font-size: 24px;
        }

        .preferences-panel {
            position: absolute;
            top: 10px;
            left: 30px;
            background-color: white;
            border: 1px solid #ccc;
            border-radius: 5px;
            padding: 5px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            z-index: 999;
            width: 250px;
            display: none;
        }

        .preferences-panel.show {
            display: flex;
        }

        .preferences-panel:not(.show) {
            display: none;
        }

        .preferences-panel h3 {
            margin-top: 0;
            margin-bottom: 10px;
            border-bottom: 1px solid #eee;
            padding-bottom: 5px;
        }

        .preference-group {
            margin-bottom: 15px;
        }

        .preference-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }

        .preference-group select,
        .preference-group input {
            width: 100%;
            padding: 5px;
            margin-bottom: 10px;
        }

        .color-preview {
            display: inline-block;
            width: 40px;
            height: 40px;
            border: 1px solid #ccc;
            vertical-align: middle;
            margin-left: 10px;
        }

        /* Preferences Panel Category Styles */
        .preferences-panel {
            display: flex;
            width: 500px;
            max-height: 80vh;
            overflow-y: auto;
        }

        .preferences-panel h3 {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            margin: 0;
            padding: 10px 15px;
            background-color: #f1f1f1;
            border-bottom: 1px solid #ccc;
            box-sizing: border-box;
        }

        .pref-categories {
            display: flex;
            flex-direction: column;
            width: 120px;
            background-color: #f1f1f1;
            border-right: 1px solid #ccc;
            padding-top: 40px; /* Space for the header */
        }

        .pref-category {
            padding: 12px 10px;
            cursor: pointer;
            border-bottom: 1px solid #ddd;
            text-align: left;
        }

        .pref-category.active {
            background-color: #fff;
            border-right: none;
            font-weight: bold;
        }

        .pref-content-container {
            flex: 1;
            padding: 15px;
            padding-top: 50px; /* Space for the header */
            padding-bottom: 60px; /* Space for the save button */
            position: relative;
        }

        .pref-content {
            display: none;
        }

        .pref-content.active {
            display: block;
        }

        .save-button-container {
            position: absolute;
            bottom: 15px;
            right: 15px;
            z-index: 10;
        }

        #savePreferences {
            padding: 8px 15px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
        }

        #savePreferences:hover {
            background-color: #45a049;
        }

        /* Piece Set Preview Styles */
        .piece-set-preview {
            width: 100%;
            border: 1px solid #ccc;
            border-radius: 4px;
            margin-top: 5px;
            background-color: #f9f9f9;
        }

        .preview-row {
            display: flex;
            justify-content: space-around;
        }

        .preview-cell {
            width: 40px;
            height: 40px;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .preview-cell img {
            max-width: 30px;
            max-height: 30px;
        }
    </style>
</head>
<body>
<!-- Hamburger Menu -->
<div class="hamburger-menu" id="hamburgerMenu">☰</div>

<h2 id="title"></h2>

<!-- Preferences Panel -->
<div class="preferences-panel" id="preferencesPanel">
    <h3>Preferences</h3>

    <!-- Category Tabs (Left Side) -->
    <div class="pref-categories">
        <div class="pref-category" data-category="fics">FICS</div>
        <div class="pref-category active" data-category="chessboard">Chess Board</div>
        <div class="pref-category" data-category="tabs">Tabs</div>
    </div>

    <!-- Content Container (Right Side) -->
    <div class="pref-content-container">
        <!-- FICS Preferences -->
        <div class="pref-content" id="pref-fics">
            <div class="preference-group">
                <label for="prefFicsUsername">FICS Username:</label>
                <input type="text" id="prefFicsUsername" placeholder="Enter your FICS username">
            </div>

            <div class="preference-group">
                <label for="prefFicsPassword">FICS Password:</label>
                <input type="password" id="prefFicsPassword" placeholder="Enter your FICS password">
                <div class="password-info" style="font-size: 12px; margin-top: 5px; color: #666;">
                    <i>Your password is stored locally and used only for FICS authentication.</i>
                </div>
            </div>

            <div class="preference-group">
                <label for="prefAutoLogin">Auto Login:</label>
                <div style="display: flex; align-items: center;">
                    <input type="checkbox" id="prefAutoLogin" style="width: auto; margin-right: 5px;" checked>
                    <span>Automatically login when connecting to FICS</span>
                </div>
            </div>
        </div>

        <!-- Chess Board Preferences -->
        <div class="pref-content active" id="pref-chessboard">
            <div class="preference-group">
                <label for="prefPieceSet">Chess Piece Set:</label>
                <select id="prefPieceSet">
                    <option value="alpha">Alpha</option>
                    <option value="anarcandy">Anarcandy</option>
                    <option value="california">California</option>
                    <option value="cardinal">Cardinal</option>
                    <option value="cburnett">Cburnett</option>
                    <option value="celtic">Celtic</option>
                    <option value="chess7">Chess7</option>
                    <option value="chessnut">Chessnut</option>
                    <option value="companion">Companion</option>
                    <option value="disguised">Disguised</option>
                    <option value="dubrovny">Dubrovny</option>
                    <option value="fantasy">Fantasy</option>
                    <option value="fresca">Fresca</option>
                    <option value="gioco">Gioco</option>
                    <option value="governor">Governor</option>
                    <option value="horsey">Horsey</option>
                    <option value="icpieces">Icpieces</option>
                    <option value="kiwen-suwi">Kiwen-Suwi</option>
                    <option value="kosal">Kosal</option>
                    <option value="leipzig">Leipzig</option>
                    <option value="letter">Letter</option>
                    <option value="libra">Libra</option>
                    <option value="maestro">Maestro</option>
                    <option value="merida">Merida</option>
                    <option value="mpchess">Mpchess</option>
                    <option value="pirouetti">Pirouetti</option>
                    <option value="pixel">Pixel</option>
                    <option value="reillycraig">Reillycraig</option>
                    <option value="riohacha">Riohacha</option>
                    <option value="shapes">Shapes</option>
                    <option value="spatial">Spatial</option>
                    <option value="staunty">Staunty</option>
                    <option value="tatiana">Tatiana</option>
                </select>
            </div>

            <div class="preference-group">
                <label>Piece Set Preview:</label>
                <div id="pieceSetPreview" class="piece-set-preview">
                    <!-- 5x4 grid for piece preview -->
                    <div class="preview-row">
                        <div class="preview-cell"><img id="preview-bR" src="" alt="bR"></div>
                        <div class="preview-cell"><img id="preview-bN" src="" alt="bN"></div>
                        <div class="preview-cell"><img id="preview-bB" src="" alt="bB"></div>
                        <div class="preview-cell"><img id="preview-bQ" src="" alt="bQ"></div>
                        <div class="preview-cell"><img id="preview-bK" src="" alt="bK"></div>
                    </div>
                    <div class="preview-row">
                        <div class="preview-cell"><img id="preview-bP" src="" alt="bP"></div>
                        <div class="preview-cell"><img id="preview-bP" src="" alt="bP"></div>
                        <div class="preview-cell"><img id="preview-bP" src="" alt="bP"></div>
                        <div class="preview-cell"><img id="preview-bP" src="" alt="bP"></div>
                        <div class="preview-cell"><img id="preview-bP" src="" alt="bP"></div>
                    </div>
                    <div class="preview-row">
                        <div class="preview-cell"><img id="preview-wP" src="" alt="wP"></div>
                        <div class="preview-cell"><img id="preview-wP" src="" alt="wP"></div>
                        <div class="preview-cell"><img id="preview-wP" src="" alt="wP"></div>
                        <div class="preview-cell"><img id="preview-wP" src="" alt="wP"></div>
                        <div class="preview-cell"><img id="preview-wP" src="" alt="wP"></div>
                    </div>
                    <div class="preview-row">
                        <div class="preview-cell"><img id="preview-wR" src="" alt="wR"></div>
                        <div class="preview-cell"><img id="preview-wN" src="" alt="wN"></div>
                        <div class="preview-cell"><img id="preview-wB" src="" alt="wB"></div>
                        <div class="preview-cell"><img id="preview-wQ" src="" alt="wQ"></div>
                        <div class="preview-cell"><img id="preview-wK" src="" alt="wK"></div>
                    </div>
                </div>
            </div>

            <div class="preference-group">
                <label for="prefLightSquare">Light Square Color:</label>
                <div style="display: flex; align-items: center;">
                    <input type="color" id="prefLightSquare" value="#e8e0c8" style="width: 60px;">
                    <div class="color-preview" id="lightSquarePreview" style="background-color: #e8e0c8;"></div>
                </div>
            </div>

            <div class="preference-group">
                <label for="prefDarkSquare">Dark Square Color:</label>
                <div style="display: flex; align-items: center;">
                    <input type="color" id="prefDarkSquare" value="#AB8B69" style="width: 60px;">
                    <div class="color-preview" id="darkSquarePreview" style="background-color: #AB8B69;"></div>
                </div>
            </div>



        </div>

        <!-- Tabs Preferences -->
        <div class="pref-content" id="pref-tabs">
            <div class="preference-group">
                <label>Message Routing:</label>

                <div style="margin-top: 10px;">
                    <div style="display: flex; align-items: center; margin-bottom: 8px;">
                        <input type="checkbox" id="prefChannelTellsToTabs" style="width: auto; margin-right: 10px;" checked>
                        <label for="prefChannelTellsToTabs" style="font-weight: normal;">Send all channel tells to channel tabs</label>
                    </div>

                    <div style="display: flex; align-items: center; margin-bottom: 8px;">
                        <input type="checkbox" id="prefDirectTellsToTabs" style="width: auto; margin-right: 10px;" checked>
                        <label for="prefDirectTellsToTabs" style="font-weight: normal;">Send all direct tells to direct tell tab</label>
                    </div>

                    <div style="display: flex; align-items: center; margin-bottom: 8px;">
                        <input type="checkbox" id="prefGameTellsToTabs" style="width: auto; margin-right: 10px;" checked>
                        <label for="prefGameTellsToTabs" style="font-weight: normal;">Send all game tells to game tab</label>
                    </div>
                </div>
            </div>

            <div class="preference-group">
                <label>Tab Behavior:</label>

                <div style="margin-top: 10px;">
                    <div style="display: flex; align-items: center; margin-bottom: 8px;">
                        <input type="checkbox" id="prefAutoSwitchToNewTabs" style="width: auto; margin-right: 10px;" checked>
                        <label for="prefAutoSwitchToNewTabs" style="font-weight: normal;">Automatically switch to new tabs when created</label>
                    </div>

                    <div style="display: flex; align-items: center; margin-bottom: 8px;">
                        <input type="checkbox" id="prefFlashTabsOnActivity" style="width: auto; margin-right: 10px;" checked>
                        <label for="prefFlashTabsOnActivity" style="font-weight: normal;">Flash tabs on new activity</label>
                    </div>

                    <div style="display: flex; align-items: center; margin-bottom: 8px;">
                        <input type="checkbox" id="prefShowStyle12Events" style="width: auto; margin-right: 10px;">
                        <label for="prefShowStyle12Events" style="font-weight: normal;">Show Style12 events in console (for debugging)</label>
                    </div>
                </div>
            </div>
        </div>

        <!-- Save Button (Bottom Right) -->
        <div class="save-button-container">
            <button id="savePreferences">Save Preferences</button>
        </div>
    </div>
</div>
<div class="main-container">
    <!-- Top section with chess tabs and right side content -->
    <div class="top-section">
        <!-- Chess board (left side) -->
        <div class="chess-board-area">
            <!-- Board will be created here dynamically -->
        </div>

        <!-- Horizontal resizable divider with collapse buttons -->
        <div class="divider horizontal-divider" id="topDivider">
            <div class="divider-controls">
                <button id="collapseLeft" class="triangle-button" title="Collapse to left">◀</button>
                <button id="collapseRight" class="triangle-button" title="Collapse to right">▶</button>
            </div>
        </div>

        <!-- Right side content (main console and chat tabs) -->
        <div class="right-content">
            <!-- Main console (top right) -->
            <div class="main-console">
                <div class="grid-container">
                    <div class="grid-row" style="flex: 1; display: flex; flex-direction: column;">
                        <textarea id="mainTextArea" class="ics-text-area" readonly style="flex: 1; min-height: 100px; max-height: calc(100% - 15px);"></textarea>
                    </div>
                    <div class="grid-row" style="padding: 0 10px 10px 10px; margin-top: 0px">
                        <input id="mainInput" class="ics-input"/>
                    </div>
                </div>
            </div>

            <!-- Vertical resizable divider with collapse buttons -->
            <div class="divider vertical-divider" id="rightDivider" style="display: none;margin-left: 3px">
                <div class="divider-controls vertical">
                    <button id="collapseUp" class="triangle-button" title="Collapse upward">▲</button>
                    <button id="collapseDown" class="triangle-button" title="Collapse downward">▼</button>
                </div>
            </div>

            <!-- Chat tabs (bottom right) -->
            <div class="chat-tabs-container">
                <div id="tabset" class="tabset">
                    <div id="tabs" class="tabs"></div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.10.2/chess.min.js"></script>
<script>
    const wsUrl = 'wss://www.freechess.org:5001';
    const mainTextArea = document.getElementById('mainTextArea');
    const mainInput = document.getElementById('mainInput');
    const statusDiv = document.getElementById('status');
    const tabSet = document.getElementById('tabset');
    const tabs = document.getElementById('tabs');
    const moveAudio = new Audio('sounds/move.ogg');
    const captureAudio = new Audio('sounds/capture.ogg');
    let chess = new Chess(); // Using the chess.js library
    let selectedSquare = null;
    let validMoves = [];
    let myColor = 'white'; // Will be updated based on game info
    let isLoggingIn = false;
    let ws = null;
    let boardInitialized = false; // Track if the board has been initialized

    // Game information variables
    let whitePlayerName = '';
    let blackPlayerName = '';
    let whitePlayerClock = '00:00';
    let blackPlayerClock = '00:00';
    let currentTurn = 'w'; // 'w' for white, 'b' for black
    let whiteTimeSeconds = 0;
    let blackTimeSeconds = 0;
    let clockTimer = null;
    let isClockRunning = false;

    // Additional Style 12 information
    let gameInfo = {
        gameNumber: 0,
        initialTime: 0,      // Initial time in seconds
        increment: 0,        // Increment in seconds
        whiteMaterial: 0,    // White material strength
        blackMaterial: 0,    // Black material strength
        moveNumber: 0,       // Number of the move about to be made
        lastMove: '',        // Verbose coordinate notation for the previous move
        lastMoveTime: '',    // Time taken to make previous move
        lastMovePretty: '',  // Pretty notation for the previous move
        relation: 0,         // My relation to this game (-1, 0, 1, etc.)
        doublePawnPush: -1,  // -1 if no double pawn push, otherwise the file (0-7 for a-h)
        whiteCastleShort: 0, // Can White castle short? (0=no, 1=yes)
        whiteCastleLong: 0,  // Can White castle long? (0=no, 1=yes)
        blackCastleShort: 0, // Can Black castle short? (0=no, 1=yes)
        blackCastleLong: 0,  // Can Black castle long? (0=no, 1=yes)
        irreversibleCount: 0 // Moves since last irreversible move (for 50-move rule)
    };

    // Set up the resizable dividers
    const topDivider = document.getElementById('topDivider');
    const rightDivider = document.getElementById('rightDivider');
    const chessBoardArea = document.querySelector('.chess-board-area');
    const rightContent = document.querySelector('.right-content');
    const mainConsole = document.querySelector('.main-console');
    const chatTabsContainer = document.querySelector('.chat-tabs-container');

    // Variables to track which divider is being dragged
    let activeResizer = null;

    // Add event listeners for the horizontal divider (between chess tabs and right content)
    topDivider.addEventListener('mousedown', function(e) {
        // Only start resize if the click is on the divider itself, not on the buttons
        if (e.target === topDivider) {
            e.preventDefault();
            activeResizer = 'horizontal';
            document.addEventListener('mousemove', resizeDividers);
            document.addEventListener('mouseup', stopResize);
        }
    });

    // Add event listeners for the collapse buttons
    const collapseLeftBtn = document.getElementById('collapseLeft');
    const collapseRightBtn = document.getElementById('collapseRight');

    collapseLeftBtn.addEventListener('click', function() {
        // Collapse to the left (hide chess board area)
        chessBoardArea.style.flexBasis = '0%';
        topDivider.style.left = '0%';
        // Scroll consoles to bottom after collapsing with a delay
        setTimeout(scrollConsolesToBottom, 100);
    });

    collapseRightBtn.addEventListener('click', function() {
        // Collapse to the right (maximize chess board area)
        chessBoardArea.style.flexBasis = '100%';
        topDivider.style.left = '100%';
        // Scroll consoles to bottom after collapsing with a delay
        setTimeout(scrollConsolesToBottom, 100);
    });

    // Add event listeners for the vertical divider (between main console and chat tabs)
    rightDivider.addEventListener('mousedown', function(e) {
        // Only start resize if the click is on the divider itself, not on the buttons
        if (e.target === rightDivider) {
            e.preventDefault();
            activeResizer = 'vertical';
            document.addEventListener('mousemove', resizeDividers);
            document.addEventListener('mouseup', stopResize);
        }
    });

    // Add event listeners for the vertical collapse buttons
    const collapseUpBtn = document.getElementById('collapseUp');
    const collapseDownBtn = document.getElementById('collapseDown');

    collapseUpBtn.addEventListener('click', function() {
        // Collapse upward (maximize main console)
        mainConsole.style.flexBasis = '100%';
        rightDivider.style.top = '100%';
        // Scroll consoles to bottom after collapsing with a delay
        setTimeout(scrollConsolesToBottom, 100);
    });

    collapseDownBtn.addEventListener('click', function() {
        // Collapse downward (minimize main console)
        mainConsole.style.flexBasis = '0%';
        rightDivider.style.top = '0%';
        // Scroll consoles to bottom after collapsing with a delay
        setTimeout(scrollConsolesToBottom, 100);
    });

    function resizeDividers(e) {
        if (activeResizer === 'horizontal') {
            // Resize horizontal divider (left-right)
            const container = document.querySelector('.top-section');
            const containerRect = container.getBoundingClientRect();
            let percentage = ((e.clientX - containerRect.left) / containerRect.width) * 100;

            // Limit the minimum and maximum sizes
            percentage = Math.max(20, Math.min(80, percentage));

            // Update the flex-basis of the chess board area
            chessBoardArea.style.flexBasis = `${percentage}%`;

            // Update the divider position
            topDivider.style.left = `${percentage}%`;
        } else if (activeResizer === 'vertical') {
            // Resize vertical divider (top-bottom)
            const container = rightContent;
            const containerRect = container.getBoundingClientRect();
            let percentage = ((e.clientY - containerRect.top) / containerRect.height) * 100;

            // Limit the minimum and maximum sizes
            percentage = Math.max(20, Math.min(80, percentage));

            // Update the flex-basis of the main console
            mainConsole.style.flexBasis = `${percentage}%`;

            // Update the divider position
            rightDivider.style.top = `${percentage}%`;
        }

        // During active resize, we'll just scroll the main text area directly
        // This is more efficient than scrolling all text areas during rapid resize events
        if (mainTextArea) {
            mainTextArea.scrollTop = mainTextArea.scrollHeight;
        }
    }

    // Helper function to scroll all text areas to the bottom
    function scrollConsolesToBottom() {
        // Use setTimeout to ensure this runs after the browser has updated the layout
        setTimeout(() => {
            console.log('Scrolling consoles to bottom');

            // Scroll main console to bottom
            if (mainTextArea) {
                console.log('Main text area scrollHeight:', mainTextArea.scrollHeight);
                mainTextArea.scrollTop = mainTextArea.scrollHeight;
            }

            // Scroll all tab text areas to bottom
            const tabTextAreas = document.querySelectorAll('.tab-text-area');
            console.log('Found', tabTextAreas.length, 'tab text areas');

            tabTextAreas.forEach(textArea => {
                console.log('Tab text area scrollHeight:', textArea.scrollHeight);
                textArea.scrollTop = textArea.scrollHeight;
            });

            // Also try to scroll any visible active tab content
            const activeTabContents = document.querySelectorAll('.tab-content-active');
            activeTabContents.forEach(tabContent => {
                const textAreas = tabContent.querySelectorAll('textarea');
                textAreas.forEach(textArea => {
                    console.log('Active tab textarea scrollHeight:', textArea.scrollHeight);
                    textArea.scrollTop = textArea.scrollHeight;
                });
            });
        }, 50); // Small delay to ensure DOM updates have completed
    }

    function stopResize() {
        activeResizer = null;
        document.removeEventListener('mousemove', resizeDividers);
        document.removeEventListener('mouseup', stopResize);

        // Scroll consoles to bottom after resize is complete
        // Use a slightly longer delay to ensure layout has fully updated
        setTimeout(scrollConsolesToBottom, 100);

        // Also try a direct approach for the main text area
        setTimeout(() => {
            if (mainTextArea) {
                mainTextArea.scrollTop = mainTextArea.scrollHeight;
            }
        }, 200);
    }

    // Global preferences object to store user preferences in memory
    let preferences = {
        // Chess board preferences
        pieceSet: 'cburnett',
        lightSquareColor: '#e8e0c8',
        darkSquareColor: '#AB8B69',

        // FICS preferences
        ficsUsername: '',
        ficsPassword: '',
        autoLogin: false,

        // Tabs preferences
        channelTellsToTabs: true,
        directTellsToTabs: false,
        gameTellsToTabs: false,
        autoSwitchToNewTabs: true,
        flashTabsOnActivity: true,
        showStyle12Events: false
    };

    // Default preferences
    let currentPieceSet = 'alpha';
    let lightSquareColor = '#e8e0c8';
    let darkSquareColor = '#AB8B69';

    // Load preferences from local storage
    function loadPreferences() {
        if (localStorage.getItem('chessPreferences')) {
            // Load preferences from local storage into the preferences object
            const storedPrefs = JSON.parse(localStorage.getItem('chessPreferences'));

            // Update the preferences object with stored values
            Object.assign(preferences, storedPrefs);

            console.log('Preferences loaded:', preferences);

            // Update global variables used elsewhere in the code
            currentPieceSet = preferences.pieceSet;
            lightSquareColor = preferences.lightSquareColor;
            darkSquareColor = preferences.darkSquareColor;

            // Update UI to reflect loaded preferences

            // Chess board UI
            document.getElementById('prefPieceSet').value = preferences.pieceSet;
            document.getElementById('prefLightSquare').value = preferences.lightSquareColor;
            document.getElementById('prefDarkSquare').value = preferences.darkSquareColor;
            document.getElementById('lightSquarePreview').style.backgroundColor = preferences.lightSquareColor;
            document.getElementById('darkSquarePreview').style.backgroundColor = preferences.darkSquareColor;

            // FICS preferences UI
            document.getElementById('prefFicsUsername').value = preferences.ficsUsername || '';

            if (preferences.ficsPassword) {
                try {
                    // Simple decoding of password
                    document.getElementById('prefFicsPassword').value = atob(preferences.ficsPassword);
                } catch (e) {
                    console.error('Error decoding password:', e);
                }
            }

            document.getElementById('prefAutoLogin').checked = preferences.autoLogin;

            // Tabs preferences UI
            document.getElementById('prefChannelTellsToTabs').checked = preferences.channelTellsToTabs;
            document.getElementById('prefDirectTellsToTabs').checked = preferences.directTellsToTabs;
            document.getElementById('prefGameTellsToTabs').checked = preferences.gameTellsToTabs;
            document.getElementById('prefAutoSwitchToNewTabs').checked = preferences.autoSwitchToNewTabs;
            document.getElementById('prefFlashTabsOnActivity').checked = preferences.flashTabsOnActivity;
            document.getElementById('prefShowStyle12Events').checked = preferences.showStyle12Events;

            // Initialize the piece set preview
            updatePieceSetPreview(preferences.pieceSet);

            // Apply preferences to the board
            applyPreferences();
        } else {
            // Initialize with default piece set
            updatePieceSetPreview('alpha');
            console.log('No stored preferences found, using defaults');
        }
    }

    // Save preferences to local storage
    function savePreferences() {
        // Update preferences object with current values from UI

        // Chess board preferences
        preferences.pieceSet = currentPieceSet;
        preferences.lightSquareColor = lightSquareColor;
        preferences.darkSquareColor = darkSquareColor;

        // FICS preferences
        preferences.ficsUsername = document.getElementById('prefFicsUsername').value;
        const rawPassword = document.getElementById('prefFicsPassword').value;
        preferences.ficsPassword = rawPassword ? btoa(rawPassword) : ''; // Simple encoding for password
        preferences.autoLogin = document.getElementById('prefAutoLogin').checked;

        // Tabs preferences
        preferences.channelTellsToTabs = document.getElementById('prefChannelTellsToTabs').checked;
        preferences.directTellsToTabs = document.getElementById('prefDirectTellsToTabs').checked;
        preferences.gameTellsToTabs = document.getElementById('prefGameTellsToTabs').checked;
        preferences.autoSwitchToNewTabs = document.getElementById('prefAutoSwitchToNewTabs').checked;
        preferences.flashTabsOnActivity = document.getElementById('prefFlashTabsOnActivity').checked;
        preferences.showStyle12Events = document.getElementById('prefShowStyle12Events').checked;

        // Save to local storage
        localStorage.setItem('chessPreferences', JSON.stringify(preferences));

        console.log('Preferences saved:', preferences);
    }

    // Apply preferences to the board
    function applyPreferences() {
        // Update piece set
        if (document.getElementById('chessBoard')) {
            updateBoardFromChessJS();
        }

        // Update square colors
        const lightSquares = document.querySelectorAll('.light-square');
        const darkSquares = document.querySelectorAll('.dark-square');

        lightSquares.forEach(square => {
            square.style.backgroundColor = lightSquareColor;
        });

        darkSquares.forEach(square => {
            square.style.backgroundColor = darkSquareColor;
        });

        // Update rank and file label colors based on square colors
        const rankLabels = document.querySelectorAll('.rank-label');
        const fileLabels = document.querySelectorAll('.file-label');

        rankLabels.forEach(label => {
            // Get the parent square
            const square = label.parentElement;
            // Set color based on square type for better contrast
            if (square.classList.contains('light-square')) {
                // If it's a light square, use dark square color
                label.style.color = preferences.darkSquareColor;
            } else {
                // If it's a dark square, use light square color
                label.style.color = preferences.lightSquareColor;
            }
        });

        fileLabels.forEach(label => {
            // Get the parent square
            const square = label.parentElement;
            // Set color based on square type for better contrast
            if (square.classList.contains('light-square')) {
                // If it's a light square, use dark square color
                label.style.color = preferences.darkSquareColor;
            } else {
                // If it's a dark square, use light square color
                label.style.color = preferences.lightSquareColor;
            }
        });
    }

    mainInput.addEventListener('keypress', (event) => {
        switch (event.key) {
            case "Enter":
              const message = mainInput.value;
              ws.send(filterInvalid(message) + '\n\r');
              mainInput.value = '';
              break;
        }
    });

    function connectWebSocket() {
        ws = new WebSocket(wsUrl);
        ws.addEventListener("message", (event) => {
             if (event.data instanceof Blob) {
               const reader = new FileReader();
               reader.onload = function(e) {
                 var msg = reader.result;
                 routeMessage(msg);
               };
               reader.readAsText(event.data);
             } else {
               routeMessage(event.data);
             }
           });

        ws.onopen = () => {
            routeMessage('Connected\n');
            if (isAutoLoginEnabled()) {
                isLoggingIn=true;
            }
        };

        ws.onerror = (error) => {
            routeMessage(`Error: ${JSON.stringify(error)}\n`);
            statusDiv.textContent = 'Error';
        };

        ws.onclose = () => {
            routeMessage('Disconnected\n');
            statusDiv.textContent = 'Disconnected';
            ws = null;
            setTimeout(connectWebSocket, 5000);
        };
    }

    // Check if auto-login is enabled
    function isAutoLoginEnabled() {
        // Use the preferences object directly
        return preferences.autoLogin === true &&
               preferences.ficsUsername &&
               preferences.ficsPassword;
    }

    function filterInvalid(msg) {
        var result = '';
        var filtered = "";
        for (var i = 0; i < msg.length; i++) {
           if (msg.charCodeAt(i) >= 32 && msg.charCodeAt(i) <= 126) {
              result += msg.charAt(i);
           } else {
              filtered += msg.charAt(i);
           }
        }
        if (filtered != '') {
            routeMessage('\nFiltered output: ' + filtered);
        }
        return result;
    }

    function inactiveAllTabs() {
        // Hide all chat tab content
        const allTabContents = document.querySelectorAll("#tabset .tab-content");
        for (let i = 0; i < allTabContents.length; i++) {
            allTabContents[i].classList.remove("tab-content-active");
            allTabContents[i].classList.add("tab-content-inactive");

            // Ensure the display property is set to none
            allTabContents[i].style.display = 'none';
        }

        const allTabs = document.querySelectorAll("#tabs .tab");
        // Remove active class from all chat tabs
        for (let i = 0; i < allTabs.length; i++) {
            allTabs[i].classList.remove("tab-active");
            allTabs[i].classList.add("tab-inactive");
        }
    }

    function inactiveAllChessTabs() {
        // Hide all chess tab content
        const activeTabContents = document.querySelectorAll("#chessTabset .tab-content");
        for (let i = 0; i < activeTabContents.length; i++) {
            activeTabContents[i].classList.remove("tab-content-active");
            activeTabContents[i].classList.add("tab-content-inactive");
        }

        const activeTabs = document.querySelectorAll("#chessTabs .tab");
        // Remove active class from all chess tabs
        for (let i = 0; i < activeTabs.length; i++) {
            activeTabs[i].classList.remove("tab-active");
            activeTabs[i].classList.add("tab-inactive");
        }
    }

    // Function to check if there are any tabs open and adjust the layout
    function updateTabsVisibility() {
        const tabElements = document.querySelectorAll('#tabs .tab');
        const rightDivider = document.getElementById('rightDivider');
        const mainConsole = document.querySelector('.main-console');
        const chatTabsContainer = document.querySelector('.chat-tabs-container');
        const rightContent = document.querySelector('.right-content');

        if (tabElements.length > 0) {
            // Show the divider and set 50/50 split when tabs exist
            rightDivider.style.display = 'block';
            mainConsole.style.flex = '0 0 50%';
            chatTabsContainer.style.display = 'flex';

            // Explicitly set the divider position to 50%
            rightDivider.style.top = '50%';

            // Force a layout recalculation to ensure the divider is positioned correctly
            setTimeout(() => {
                // Trigger a resize event to ensure all elements are properly positioned
                window.dispatchEvent(new Event('resize'));
            }, 0);
        } else {
            // Hide the divider and give full height to main console when no tabs
            rightDivider.style.display = 'none';
            mainConsole.style.flex = '1';
            chatTabsContainer.style.display = 'none';
        }
    }

    function createTab(type, name) {
        const id = type + "-" + name;

        // Make all existing tabs inactive
        inactiveAllTabs();

        // Create the new tab
        const tabDiv = document.createElement('div');
        tabDiv.id= 'tab-' + id;
        tabDiv.classList.add("tab-active");
        tabDiv.classList.add("tab");
        tabs.append(tabDiv);

        const tabLabel = document.createElement('span');
        tabLabel.id= 'tab-label-' + id;
        tabLabel.innerHTML=type + " " + name + "&nbsp";
        tabLabel.addEventListener('click', function(event) {
           const id = event.target.id.replace("tab-label-","");
           const tab = document.getElementById("tab-" + id);
           if (tab) {
               // Make all console tabs inactive first, don't affect chess tabs
               inactiveAllTabs();

               // Make this tab active
               tab.classList.remove('tab-inactive');
               tab.classList.add('tab-active');

               // Show this tab's content
               const tabContent = document.getElementById("tab-content-" + id);
               tabContent.classList.remove('tab-content-inactive');
               tabContent.classList.add('tab-content-active');
               tabContent.style.display = 'flex'; // Ensure it's visible
           }
        });
        tabDiv.append(tabLabel);

        const tabDivSpan = document.createElement('span');
        tabDivSpan.innerHTML = "x";
        tabDivSpan.classList.add('close-btn');
        tabDivSpan.addEventListener('click', function(event) {
            closeTab(id);
        });
        tabDiv.append(tabDivSpan);

        const tabContent = document.createElement('div');
        tabContent.id='tab-content-' + id;
        tabContent.classList.add('tab-content');
        tabContent.classList.add('tab-content-active');
        tabContent.classList.add('grid-container');
        tabContent.style.display = 'flex'; // Ensure it's visible initially
        tabContent.style.flexDirection = 'column';
        tabContent.style.height = '100%';
        tabSet.append(tabContent);

        // Make all other tab contents inactive and hidden
        const otherTabContents = document.querySelectorAll('#tabset .tab-content:not(#tab-content-' + id + ')');
        for (let i = 0; i < otherTabContents.length; i++) {
            otherTabContents[i].classList.remove('tab-content-active');
            otherTabContents[i].classList.add('tab-content-inactive');
            otherTabContents[i].style.display = 'none';
        }

        // Text area container with flex: 1 to fill available space
        const row1 = document.createElement('div');
        row1.classList.add('grid-row');
        row1.style.flex = '1';
        row1.style.display = 'flex';
        row1.style.flexDirection = 'column';
        row1.style.minHeight= '100px';
        row1.style.maxHeight= 'calc(100% - 15px)';

        // Input row with fixed height
        const row2 = document.createElement('div');
        row2.classList.add('grid-row');
        row2.style.setProperty("grid-template-columns","auto 1fr");
        row2.style.marginTop = '10px';

        var textArea = document.createElement('textarea');
        textArea.id='textarea-' + id;
        textArea.classList.add('tab-text-area');
        textArea.readOnly=true;
        textArea.style.flex = '1';
        textArea.style.minHeight = '100px';

        var tabInputLabel = document.createElement('span');
        tabInputLabel.classList.add('tab-input-label');
        tabInputLabel.classList.add('inputLabel');
        tabInputLabel.innerHTML = "tell " + name;

        var input = document.createElement('input');
        input.classList.add('input-' + id);
        input.classList.add('tab-Input');
        input.id='input-' + id;
        input.style.height = '24px';

        input.addEventListener('keypress', (event) => {
            switch (event.key) {
                case "Enter":
                  const message = input.value;
                  ws.send("tell " + name + " " + filterInvalid(message) + '\n\r');
                  input.value = '';
                  break;
            }
        });

        row1.append(textArea);
        row2.append(tabInputLabel);
        row2.append(input);
        tabContent.append(row1);
        tabContent.append(row2);

        // Update tabs visibility after creating a new tab
        updateTabsVisibility();
    }

    function createGameTab(opponent) {
        const id = "game-" + opponent;
        gameTabId = id;
        // Only make chess tabs inactive, don't affect console tabs
        inactiveAllChessTabs();
        const tabDiv = document.createElement('div');
        tabDiv.id = 'tab-' + id;
        tabDiv.classList.add("tab-active");
        tabDiv.classList.add("tab");
        chessTabs.append(tabDiv);

        const tabLabel = document.createElement('span');
        tabLabel.id = 'tab-label-' + id;

        // Different label for practice board vs actual games
        if (opponent === "Practice") {
            tabLabel.innerHTML = "Practice Board" + "&nbsp";
        } else {
            tabLabel.innerHTML = "Game vs " + opponent + "&nbsp";
        }
        tabLabel.addEventListener('click', function(event) {
            const id = event.target.id.replace("tab-label-","");
            const tab = document.getElementById("tab-" + id);
            if (tab) {
                // Only make chess tabs inactive, don't affect console tabs
                inactiveAllChessTabs();
                tab.classList.remove('tab-inactive');
                tab.classList.add('tab-active');
                const tabContent = document.getElementById("tab-content-" + id);
                tabContent.classList.remove('tab-content-inactive');
                tabContent.classList.add('tab-content-active');
            }
        });
        tabDiv.append(tabLabel);

        const tabDivSpan = document.createElement('span');
        tabDivSpan.innerHTML = "x";
        tabDivSpan.classList.add('close-btn');
        tabDivSpan.addEventListener('click', function(event) {
            // If this is the active game tab, stop the clock
            if (id === gameTabId) {
                stopClock();
            }

            closeTab(id);
            gameTabId = null;
        });
        tabDiv.append(tabDivSpan);

        const tabContent = document.createElement('div');
        tabContent.id = 'tab-content-' + id;
        tabContent.classList.add('tab-content');
        tabContent.classList.add('tab-content-active');
        tabContent.classList.add('grid-container');
        chessTabSet.append(tabContent);

        // Main container for board and toolbar
        const boardAndToolbarContainer = document.createElement('div');
        boardAndToolbarContainer.classList.add('grid-row');
        boardAndToolbarContainer.style.display = 'flex';
        boardAndToolbarContainer.style.flexDirection = 'column';
        boardAndToolbarContainer.style.alignItems = 'center';

        // Create toolbar
        const toolbar = document.createElement('div');
        toolbar.classList.add('board-toolbar');
        toolbar.style.width = '400px'; // Match board width

        // Create toolbar buttons
        if (opponent === "Practice") {
            // Reset button
            const resetBtn = document.createElement('button');
            resetBtn.title = 'Reset Board';
            resetBtn.innerHTML = '<i class="material-icons">restart_alt</i>';
            resetBtn.onclick = () => {
                chess.reset();
                updateBoardFromChessJS();
            };
            toolbar.appendChild(resetBtn);
        } else {
            // Game control buttons
            const startBtn = document.createElement('button');
            startBtn.title = 'Start Game';
            startBtn.innerHTML = '<i class="material-icons">play_arrow</i>';
            startBtn.onclick = () => ws.send(`match ${opponent}\n\r`);
            toolbar.appendChild(startBtn);

            const drawBtn = document.createElement('button');
            drawBtn.title = 'Offer Draw';
            drawBtn.innerHTML = '<i class="material-icons">handshake</i>';
            drawBtn.onclick = () => ws.send('draw\n\r');
            toolbar.appendChild(drawBtn);

            const resignBtn = document.createElement('button');
            resignBtn.title = 'Resign';
            resignBtn.innerHTML = '<i class="material-icons">flag</i>';
            resignBtn.onclick = () => ws.send('resign\n\r');
            toolbar.appendChild(resignBtn);
        }

        // Flip board button (for all boards)
        const flipBtn = document.createElement('button');
        flipBtn.title = 'Flip Board';
        flipBtn.innerHTML = '<i class="material-icons">swap_vert</i>';
        flipBtn.onclick = () => {
            // Send flip command to FICS
            ws.send('flip\n\r');

            // Send refresh command after a short delay to ensure the board is updated
            setTimeout(() => {
                ws.send('refresh\n\r');
                console.log('Sent refresh command after flip');
            }, 300);

            // Also update local board orientation
            myColor = myColor === 'white' ? 'black' : 'white';
            updateBoardFromChessJS();
            updatePlayerInfo();
        };
        toolbar.appendChild(flipBtn);

        // Add toolbar to container
        boardAndToolbarContainer.appendChild(toolbar);

        // Chess board container
        const boardContainer = document.createElement('div');
        boardContainer.style.flexShrink = '0';
        const board = document.createElement('div');
        board.id = 'chessBoard';
        board.classList.add('chess-board');
        boardContainer.append(board);
        createChessBoard(board);

        // Add board container to main container
        boardAndToolbarContainer.appendChild(boardContainer);

        // Player info container (above the board)
        const topPlayerInfo = document.createElement('div');
        topPlayerInfo.classList.add('player-info');
        topPlayerInfo.classList.add('top-player');
        topPlayerInfo.style.display = 'flex';
        topPlayerInfo.style.justifyContent = 'space-between';
        topPlayerInfo.style.padding = '2px';
        topPlayerInfo.style.border = '1px solid #ccc';
        topPlayerInfo.style.borderRadius = '4px';

        // Top player name
        const topPlayerName = document.createElement('div');
        topPlayerName.classList.add('player-name');
        topPlayerName.id = 'topPlayerName';
        topPlayerName.innerText = 'Opponent';
        topPlayerName.style.fontWeight = 'bold';

        // Top player clock
        const topPlayerClock = document.createElement('div');
        topPlayerClock.classList.add('player-clock');
        topPlayerClock.id = 'topPlayerClock';
        topPlayerClock.innerText = '00:00';
        topPlayerClock.style.fontFamily = 'monospace';
        topPlayerClock.style.fontSize = '1.2em';

        topPlayerInfo.appendChild(topPlayerName);
        topPlayerInfo.appendChild(topPlayerClock);

        // Player info container (below the board)
        const bottomPlayerInfo = document.createElement('div');
        bottomPlayerInfo.classList.add('player-info');
        bottomPlayerInfo.classList.add('bottom-player');
        bottomPlayerInfo.style.display = 'flex';
        bottomPlayerInfo.style.justifyContent = 'space-between';
        bottomPlayerInfo.style.padding = '2px';
        bottomPlayerInfo.style.border = '1px solid #ccc';
        bottomPlayerInfo.style.borderRadius = '4px';

        // Bottom player name
        const bottomPlayerName = document.createElement('div');
        bottomPlayerName.classList.add('player-name');
        bottomPlayerName.id = 'bottomPlayerName';
        bottomPlayerName.innerText = 'You';
        bottomPlayerName.style.fontWeight = 'bold';

        // Bottom player clock
        const bottomPlayerClock = document.createElement('div');
        bottomPlayerClock.classList.add('player-clock');
        bottomPlayerClock.id = 'bottomPlayerClock';
        bottomPlayerClock.innerText = '00:00';
        bottomPlayerClock.style.fontFamily = 'monospace';
        bottomPlayerClock.style.fontSize = '1.2em';

        bottomPlayerInfo.appendChild(bottomPlayerName);
        bottomPlayerInfo.appendChild(bottomPlayerClock);

        // Add player info elements to the board container
        // First, remove the board from its parent
        if (board.parentNode) {
            board.parentNode.removeChild(board);
        }

        // Now add elements in the correct order
        boardContainer.appendChild(topPlayerInfo);
        boardContainer.appendChild(board);
        boardContainer.appendChild(bottomPlayerInfo);

        // Add container to the tab content
        tabContent.append(boardAndToolbarContainer);
    }

    function closeTab(typeAndName) {
        const tab = document.getElementById('tab-' + typeAndName);
        const content = document.getElementById('tab-content-' + typeAndName);
        if (!tab || !content) return;

        const tabsArray = Array.from(document.querySelectorAll("#tabs .tab"));
        const currentIndex = tabsArray.indexOf(tab);
        const isActive = tab.classList.contains("tab-active");

        // Remove tab and content
        tab.remove();
        content.remove();

        // If the closed tab was active, select another tab
        if (isActive) {
            const remainingTabs = document.querySelectorAll("#tabs .tab");
            if (remainingTabs.length > 0) {
                let nextTabIndex = currentIndex < remainingTabs.length ? currentIndex : currentIndex - 1;
                if (nextTabIndex < 0) nextTabIndex = 0;
                const nextTabId = remainingTabs[nextTabIndex].id.replace('tab-','');
                const nextTab = document.getElementById('tab-' + nextTabId);
                nextTab.classList.remove("tab-inactive");
                nextTab.classList.add("tab-active");
                const nextTabContent = document.getElementById('tab-content-' + nextTabId);
                nextTabContent.classList.add("tab-content-active");
                nextTabContent.classList.remove("tab-content-inactive");
            }
        }

        // Update tabs visibility after closing a tab
        updateTabsVisibility();
    }

    function routeMessage(msg) {
        msg = msg.replaceAll("\n\r","\n");
        msg = msg.replaceAll("\u0007","");
        if (!msg.endsWith("\n")) {
            msg += "\n";
        }
        if (msg.startsWith("\n")) {
            msg = msg.substring(1,msg.length);
        }

        if (isLoggingIn && preferences.autoLogin && msg.toLowerCase().includes('login: ')) {
            ws.send(preferences.ficsUsername + '\n\r');
            console.log('Sent username');
        }

        // Check for password prompt during auto-login
        if (isLoggingIn && preferences.autoLogin && msg.toLowerCase().includes('password: ')) {
            try {
                // Decode the password before sending
                const decodedPassword = atob(preferences.ficsPassword);
                ws.send(decodedPassword + '\n\r');
                console.log('Sent decoded password');
            } catch (e) {
                console.error('Error decoding password:', e);
                // Add error message directly to main text area
                mainTextArea.value += 'Error decoding password: ' + e.message + '\n';
                mainTextArea.scrollTop = mainTextArea.scrollHeight;
            }
            isLoggingIn = false;
        }

        if (msg.indexOf('\n**** Starting FICS session as') >=0) {
            ws.send('set style 12\n\r');
        }

        // Check for game start messages
        if (msg.includes('Creating: ') && msg.includes('vs.')) {
            const match = msg.match(/Creating: .* (\w+) vs\. (\w+)/);
            if (match && match.length >= 3) {
                // Initialize the board if it hasn't been done yet
                if (!boardInitialized) {
                    initializeChessBoard();
                }
                console.log("Game creation message detected");
            }
        }

        // Get tab routing preferences from the preferences object
        const channelTellsToTabs = preferences.channelTellsToTabs;
        const directTellsToTabs = preferences.directTellsToTabs;
        const gameTellsToTabs = preferences.gameTellsToTabs;
        const autoSwitchToNewTabs = preferences.autoSwitchToNewTabs;

        var isMain = true;
        var name = null;
        var type = null;

        // Handle channel tells
        if (/^[a-zA-Z0-9]+\([0-9]+\)\:\s/.test(msg)) { //channel tell.
            type = "channel";
            name = msg.split(/[()]/)[1].trim();

            if (channelTellsToTabs) {
                var tabId = type + "-" + name;
                var tab = document.getElementById("tab-" + tabId);
                if (!tab) {
                    createTab(type, name);

                    // Auto-switch to new tab if enabled
                    if (autoSwitchToNewTabs) {
                        const tabLabel = document.getElementById("tab-label-" + tabId);
                        if (tabLabel) {
                            tabLabel.click();
                        }
                    }
                }
                isMain = false;
                var textArea = document.getElementById("textarea-" + tabId);
                const autoScroll = textArea.scrollHeight - textArea.scrollTop <= textArea.clientHeight;
                textArea.value += msg;
                if (autoScroll)
                    textArea.scrollTop = textArea.scrollHeight;
            }
        }

        if (isMain && msg.trim() !== '') {
            const style12Start = msg.startsWith("<12>") ? 0 : msg.lastIndexOf("\n<12>");
            if (style12Start >= 0) {
                const end = msg.indexOf("\n",style12Start+1);

                if (end>=0) {
                    const style12Message = msg.substring(style12Start,end);
                    if (!preferences.showStyle12Events) {
                        msg = msg.substring(0,style12Start) + msg.substring(end + 1,msg.length);
                    }

                    if (!boardInitialized) {
                        initializeChessBoard();
                    }
                    updateChessBoard(style12Message);
                    parseStyle12Info(style12Message);
                }
            }
            const autoScroll = mainTextArea.scrollHeight - mainTextArea.scrollTop <= mainTextArea.clientHeight;
            mainTextArea.value += msg;
            if (autoScroll) {
                mainTextArea.scrollTop = mainTextArea.scrollHeight;
            }
        }
    }

    // Variables for drag and drop functionality
    let draggedPiece = null;
    let draggedPieceElement = null;
    let startSquare = null;

    function createChessBoard(board) {
        // Create a container for the board and labels
        const boardContainer = document.createElement('div');
        boardContainer.classList.add('chess-board-container');
        boardContainer.style.margin = '0 auto';
        board.parentNode.insertBefore(boardContainer, board);
        boardContainer.appendChild(board);

        board.innerHTML = '';

        // Set up the board as a responsive grid
        board.style.display = 'grid';
        board.style.gridTemplateColumns = 'repeat(8, 1fr)';
        board.style.gridTemplateRows = 'repeat(8, 1fr)';
        board.style.width = '100%';
        board.style.height = '100%';
        board.style.aspectRatio = '1 / 1'; // Maintain square aspect ratio

        // Create the chess squares with embedded rank and file labels
        for (let rank = 8; rank >= 1; rank--) {
            for (let file = 1; file <= 8; file++) {
                const square = document.createElement('div');
                square.classList.add('chess-square');
                square.classList.add((rank + file) % 2 === 0 ? 'light-square' : 'dark-square');
                square.id = `square-${file}-${rank}`;
                square.dataset.file = file;
                square.dataset.rank = rank;
                square.dataset.algebraic = `${String.fromCharCode(96 + file)}${rank}`;

                // Add both click and drag-drop event listeners
                square.addEventListener('click', () => handleSquareClick(file, rank));


                // Add dragover and drop events for the square
                square.addEventListener('dragover', (e) => {
                    e.preventDefault(); // Allow drop
                    if (validMoves.includes(square.dataset.algebraic)) {
                        square.classList.add('valid-move');
                    }
                });

                square.addEventListener('drop', (e) => {
                    e.preventDefault();
                    if (draggedPiece && startSquare) {
                        const targetSquare = square.dataset.algebraic;
                        handleDrop(targetSquare);
                    }
                });

                // Add rank label to rightmost squares
                if (file === 8) {
                    const rankLabel = document.createElement('div');
                    rankLabel.classList.add('rank-label');
                    rankLabel.textContent = rank;
                    rankLabel.style.right = '2px';
                    rankLabel.style.left = 'auto';
                    square.appendChild(rankLabel);
                }

                // Add file label to bottom row squares
                if (rank === 1) {
                    const fileLabel = document.createElement('div');
                    fileLabel.classList.add('file-label');
                    fileLabel.textContent = String.fromCharCode(96 + file);

                    // Move the h-file label to the left to avoid the resize handle
                    if (file === 8) {
                        fileLabel.style.right = '15px';
                    }

                    square.appendChild(fileLabel);
                }

                // Add a container for the chess piece
                const pieceElement = document.createElement('div');
                pieceElement.classList.add('chess-piece');
                // Set initial font size based on board dimensions
                const initialSquareSize = 400 / 8; // Initial board width divided by 8
                pieceElement.style.fontSize = Math.max(Math.floor(initialSquareSize * 0.8), 24) + 'px';
                square.appendChild(pieceElement);

                // Set dimensions for each square based on board size
                square.style.width = '100%';
                square.style.height = '100%';
                square.style.display = 'flex';
                square.style.justifyContent = 'center';
                square.style.alignItems = 'center';
                square.style.fontSize = '36px';
                square.style.position = 'relative';

                board.appendChild(square);
            }
        }

        // Add resize observer to update labels when board is resized
        const resizeObserver = new ResizeObserver(entries => {
            for (let entry of entries) {
                const width = entry.contentRect.width;
                const height = entry.contentRect.height;

                // Ensure the board remains square by setting height equal to width
                if (width !== height) {
                    // Use the smaller dimension to ensure it fits in the container
                    const size = Math.min(width, height);
                    board.style.width = size + 'px';
                    board.style.height = size + 'px';
                }

                const squareSize = width / 8; // Since width and height are equal, use width

                // Update font size of rank and file labels based on square size
                const rankLabels = board.querySelectorAll('.rank-label');
                const fileLabels = board.querySelectorAll('.file-label');
                const labelFontSize = Math.max(Math.floor(squareSize * 0.15), 6) + 'px';

                rankLabels.forEach(label => {
                    label.style.fontSize = labelFontSize;
                    // Only show rank labels on the rightmost column
                    const squareElement = label.parentElement;
                    const file = parseInt(squareElement.dataset.file);
                    label.style.display = file === 8 ? 'block' : 'none';

                    // Force rank labels to stay on the right side
                    label.style.right = '2px';
                    label.style.left = 'auto';
                    // Use setAttribute to ensure the style is applied
                    label.setAttribute('style', label.getAttribute('style') + '; left: auto !important; right: 2px;');
                });

                fileLabels.forEach(label => {
                    label.style.fontSize = labelFontSize;
                    // Only show file labels on the bottom row
                    const squareElement = label.parentElement;
                    const rank = parseInt(squareElement.dataset.rank);
                    const file = parseInt(squareElement.dataset.file);
                    label.style.display = rank === 1 ? 'block' : 'none';

                    // Ensure file labels are at the bottom right
                    label.style.bottom = '2px';
                    label.style.right = '2px';

                    // Special case for h-file to avoid resize handle
                    if (file === 8) {
                        label.style.right = '15px';
                    }
                });

                // Update the font size of pieces based on square size
                const pieceElements = board.querySelectorAll('.chess-piece');
                // Use a larger proportion of the square for the piece size
                const fontSize = Math.max(Math.floor(squareSize * 0.8), 24) + 'px';
                pieceElements.forEach(piece => {
                    piece.style.fontSize = fontSize;
                });

                // Also update any existing pieces in the updateBoardFromChessJS function
                if (typeof updatePieceSizes === 'function') {
                    updatePieceSizes(squareSize);
                }
            }
        });

        // Add a small resize handle to make it possible to resize the board
        const resizeHandle = document.createElement('div');
        resizeHandle.classList.add('resize-handle');
        resizeHandle.style.width = '8px';
        resizeHandle.style.height = '8px';
        board.appendChild(resizeHandle);

        // Add a manual resize handler to ensure square aspect ratio
        board.addEventListener('mousedown', (e) => {
            if (e.offsetX > board.offsetWidth - 20 && e.offsetY > board.offsetHeight - 20) {
                // Near the resize handle
                const startX = e.clientX;
                const startY = e.clientY;
                const startWidth = board.offsetWidth;

                const onMouseMove = (moveEvent) => {
                    const newWidth = startWidth + (moveEvent.clientX - startX);
                    // Set both width and height to the same value to maintain square aspect ratio
                    board.style.width = newWidth + 'px';
                    board.style.height = newWidth + 'px';
                    moveEvent.preventDefault();
                };

                const onMouseUp = () => {
                    document.removeEventListener('mousemove', onMouseMove);
                    document.removeEventListener('mouseup', onMouseUp);
                };

                document.addEventListener('mousemove', onMouseMove);
                document.addEventListener('mouseup', onMouseUp);
            }
        });

        resizeObserver.observe(board);

        // Initialize with starting position
        chess.reset();
        updateBoardFromChessJS();
    }


    function handleSquareClick(file, rank) {
        const square = `${String.fromCharCode(96 + file)}${rank}`;
        const squareDiv = document.getElementById(`square-${file}-${rank}`);

        // Check if it's the player's turn
        const playerColor = myColor === 'white' ? 'w' : 'b';
        if (chess.turn() !== playerColor) {
            // If it's not the player's turn, just return
            return;
        }

        if (selectedSquare === square) {
            // Deselect if clicked again
            selectedSquare = null;
            validMoves = [];
            updateBoardFromChessJS();
        } else if (validMoves.includes(square)) {
            // Check if this is a pawn promotion move
            const piece = chess.get(selectedSquare);
            const isPromotion = piece &&
                               piece.type === 'p' &&
                               ((piece.color === 'w' && rank === 8) ||
                                (piece.color === 'b' && rank === 1));

            if (isPromotion) {
                // Ask user what piece to promote to
                const promotionPiece = prompt('Promote pawn to: (q)ueen, (r)ook, (b)ishop, (n)knight', 'q');
                const validPromotions = ['q', 'r', 'b', 'n'];
                const promotion = validPromotions.includes(promotionPiece) ? promotionPiece : 'q';

                // Make move with promotion
                const move = {
                    from: selectedSquare,
                    to: square,
                    promotion: promotion
                };
                chess.move(move);
                ws.send(`move ${move.from}${move.to}=${promotion}\n\r`);
            } else {
                // Get the file and rank numbers for animation
                const fromFile = selectedSquare.charCodeAt(0) - 96;
                const fromRank = parseInt(selectedSquare.charAt(1));
                const toFile = file;
                const toRank = rank;

                // Prepare animation data
                const fromSquare = { file: fromFile, rank: fromRank };
                const toSquare = { file: toFile, rank: toRank };

                // Make regular move
                const move = {
                    from: selectedSquare,
                    to: square
                };
                chess.move(move);
                ws.send(`move ${move.from}${move.to}\n\r`);

                // Animate the piece movement
                animatePieceMove(fromSquare, toSquare, () => {
                    // Play sound after animation completes
                    if (move.captured) {
                        captureAudio.play();
                    } else {
                        moveAudio.play();
                    }

                    // Update the board after animation completes
                    updateBoardFromChessJS();
                });
            }

            // Reset selection
            selectedSquare = null;
            validMoves = [];

            // Update the current turn and restart the clock
            currentTurn = chess.turn();
            restartClock(); // Restart the clock for the new player
        } else {
            // Check if the square has a piece
            const piece = chess.get(square);
            if (piece) {
                // Only allow selecting pieces of the player's color
                const playerColor = myColor === 'white' ? 'w' : 'b';

                if (piece.color === playerColor) {
                    // Select new square and highlight valid moves
                    selectedSquare = square;
                    validMoves = chess.moves({ square: square, verbose: true }).map(move => move.to);
                    updateBoardFromChessJS();
                }
            }
        }
    }

    // Function to update piece sizes based on square size
    function updatePieceSizes(squareSize) {
        const pieceElements = document.querySelectorAll('.chess-piece');
        // For Material Symbols font, we need to adjust the size to fill the square properly
        const fontSize = Math.max(Math.floor(squareSize * 0.8), 24) + 'px';
        pieceElements.forEach(piece => {
            piece.style.fontSize = fontSize;
        });
    }

    // Function to detect a move between two positions and animate it
    function detectAndAnimateMove(oldFen, newFen, callback) {
        // Create temporary chess instances to analyze the positions
        const oldChess = new Chess(oldFen);
        const newChess = new Chess(newFen);

        // If the turn has changed, a move was made
        if (oldChess.turn() !== newChess.turn()) {
            // Find the piece that moved
            let fromSquare = null;
            let toSquare = null;

            // Check each square
            for (let file = 1; file <= 8; file++) {
                for (let rank = 1; rank <= 8; rank++) {
                    const square = `${String.fromCharCode(96 + file)}${rank}`;
                    const oldPiece = oldChess.get(square);
                    const newPiece = newChess.get(square);

                    // If a piece was on this square in the old position but not in the new position,
                    // it might be the piece that moved (or was captured)
                    if (oldPiece && (!newPiece || oldPiece.type !== newPiece.type || oldPiece.color !== newPiece.color)) {
                        // This could be the from square
                        if (!fromSquare) {
                            fromSquare = { file, rank };
                        }
                    }

                    // If a piece is on this square in the new position but not in the old position,
                    // or if the piece changed, this might be the to square
                    if (newPiece && (!oldPiece || oldPiece.type !== newPiece.type || oldPiece.color !== newPiece.color)) {
                        // This could be the to square
                        if (!toSquare) {
                            toSquare = { file, rank };
                        }
                    }
                }
            }

            // If we found both squares, animate the move
            if (fromSquare && toSquare) {
                animatePieceMove(fromSquare, toSquare, callback);
                return;
            }
        }

        // If we couldn't detect a move or there was no move, just call the callback
        if (callback) callback();
    }

    // Function to animate a piece movement
    function animatePieceMove(fromSquare, toSquare, callback) {
        const board = document.getElementById('chessBoard');
        if (!board) {
            if (callback) callback();
            return;
        }

        // Get the source and destination elements
        const fromElement = document.getElementById(`square-${fromSquare.file}-${fromSquare.rank}`);
        const toElement = document.getElementById(`square-${toSquare.file}-${toSquare.rank}`);

        if (!fromElement || !toElement) {
            if (callback) callback();
            return;
        }

        // Get the piece element from the source square
        const pieceElement = fromElement.querySelector('.chess-piece');
        if (!pieceElement || !pieceElement.innerHTML.trim()) {
            if (callback) callback();
            return;
        }

        // Save the piece content
        const pieceContent = pieceElement.innerHTML;

        // Hide the original piece during animation
        pieceElement.innerHTML = '';

        // Create a new piece element for animation
        const animatedPiece = document.createElement('div');
        animatedPiece.classList.add('chess-piece', 'animated-piece');
        animatedPiece.innerHTML = pieceContent;
        animatedPiece.style.zIndex = '1000';
        animatedPiece.style.pointerEvents = 'none';

        // Calculate the square size
        const squareSize = board.clientWidth / 8;

        // Position the animated piece at the starting position
        board.appendChild(animatedPiece);
        animatedPiece.style.position = 'absolute';
        animatedPiece.style.width = squareSize + 'px';
        animatedPiece.style.height = squareSize + 'px';
        animatedPiece.style.display = 'flex';
        animatedPiece.style.justifyContent = 'center';
        animatedPiece.style.alignItems = 'center';

        // Calculate the starting position (in board coordinates)
        const startX = (fromSquare.file - 1) * squareSize;
        const startY = (8 - fromSquare.rank) * squareSize;

        // Calculate the ending position (in board coordinates)
        const endX = (toSquare.file - 1) * squareSize;
        const endY = (8 - toSquare.rank) * squareSize;

        // Set the initial position
        animatedPiece.style.left = startX + 'px';
        animatedPiece.style.top = startY + 'px';

        // Start the animation
        setTimeout(() => {
            animatedPiece.style.transition = 'left 0.225s ease-out, top 0.225s ease-out';
            animatedPiece.style.left = endX + 'px';
            animatedPiece.style.top = endY + 'px';

            // Remove the animated piece and update the destination square after animation completes
            setTimeout(() => {
                animatedPiece.remove();
                if (callback) callback();
            }, 225); // Match the transition duration (25% faster than 300ms)
        }, 10);
    }

    function updateBoardFromChessJS(lastMove) {
        // Get the board dimensions to scale pieces appropriately
        const board = document.getElementById('chessBoard');
        const squareSize = board ? board.clientWidth / 8 : 50;
        const fontSize = Math.max(Math.floor(squareSize * 0.8), 24) + 'px';
        const labelFontSize = Math.max(Math.floor(squareSize * 0.15), 6) + 'px';

        for (let rank = 8; rank >= 1; rank--) {
            for (let file = 1; file <= 8; file++) {
                const square = `${String.fromCharCode(96 + file)}${rank}`;
                const squareDiv = document.getElementById(`square-${file}-${rank}`);
                if (!squareDiv) continue;

                // Update font size based on board size
                squareDiv.style.fontSize = fontSize;

                const piece = chess.get(square);
                let pieceSymbol = '';

                if (piece) {
                    // Use SVG images for chess pieces
                    const pieceColor = piece.color === 'w' ? 'w' : 'b';
                    const pieceType = piece.type.toUpperCase();
                    pieceSymbol = `<img src="pieces/${currentPieceSet}/${pieceColor}${pieceType}.svg" alt="${pieceColor}${pieceType}" />`;
                }

                // Check if we need to create or update the rank and file labels
                let rankLabel = squareDiv.querySelector('.rank-label');
                let fileLabel = squareDiv.querySelector('.file-label');

                // If labels don't exist, create them
                if (!rankLabel) {
                    rankLabel = document.createElement('div');
                    rankLabel.classList.add('rank-label');
                    rankLabel.textContent = rank;
                    squareDiv.appendChild(rankLabel);
                }

                if (!fileLabel) {
                    fileLabel = document.createElement('div');
                    fileLabel.classList.add('file-label');
                    fileLabel.textContent = String.fromCharCode(96 + file);
                    squareDiv.appendChild(fileLabel);
                }

                // Update label visibility and position
                rankLabel.style.fontSize = labelFontSize;
                rankLabel.style.display = file === 8 ? 'block' : 'none';

                // Force rank labels to stay on the right side
                rankLabel.style.left = 'auto !important';
                rankLabel.style.right = '2px';
                rankLabel.setAttribute('style', rankLabel.getAttribute('style') + '; left: auto !important;');

                fileLabel.style.fontSize = labelFontSize;
                fileLabel.style.display = rank === 1 ? 'block' : 'none';
                fileLabel.style.bottom = '2px'; // Ensure it's always at the bottom
                fileLabel.style.left = '2px'; // Position on the left
                fileLabel.style.right = 'auto'; // Clear any right positioning

                // Set label colors based on square color for better contrast
                if (squareDiv.classList.contains('light-square')) {
                    // If it's a light square, use dark square color
                    rankLabel.style.color = darkSquareColor;
                    fileLabel.style.color = darkSquareColor;
                } else {
                    // If it's a dark square, use light square color
                    rankLabel.style.color = lightSquareColor;
                    fileLabel.style.color = lightSquareColor;
                }

                // No need for special handling of h-file label anymore since all labels are on the left

                // Create a piece element or update existing one
                let pieceElement = squareDiv.querySelector('.chess-piece');
                if (!pieceElement) {
                    pieceElement = document.createElement('div');
                    pieceElement.classList.add('chess-piece');
                    squareDiv.appendChild(pieceElement);
                }

                // Clear any previous event listeners
                const newPieceElement = pieceElement.cloneNode(false);
                if (pieceElement.parentNode) {
                    pieceElement.parentNode.replaceChild(newPieceElement, pieceElement);
                }
                pieceElement = newPieceElement;
                squareDiv.appendChild(pieceElement);

                pieceElement.innerHTML = pieceSymbol;
                pieceElement.style.fontSize = Math.max(Math.floor(squareSize * 0.8), 24) + 'px';

                // Add drag events to pieces
                if (piece) {
                    const playerColor = myColor === 'white' ? 'w' : 'b';

                    // Only allow dragging player's own pieces and only on their turn
                    if (piece.color === playerColor && chess.turn() === playerColor) {
                        pieceElement.setAttribute('draggable', 'true');

                        pieceElement.addEventListener('dragstart', (e) => {
                            // Store the piece and starting square
                            draggedPiece = piece;
                            draggedPieceElement = pieceElement;
                            startSquare = square;

                            // Highlight valid moves
                            validMoves = chess.moves({ square: square, verbose: true }).map(move => move.to);
                            updateBoardHighlights();

                            // Add dragging class for styling
                            setTimeout(() => {
                                pieceElement.classList.add('dragging');
                            }, 0);
                        });

                        pieceElement.addEventListener('dragend', () => {
                            // Clean up after dragging ends
                            pieceElement.classList.remove('dragging');

                            // Reset if the piece wasn't dropped on a valid square
                            if (draggedPiece) {
                                draggedPiece = null;
                                draggedPieceElement = null;
                                startSquare = null;
                                validMoves = [];
                                updateBoardHighlights();
                            }
                        });
                    } else {
                        pieceElement.setAttribute('draggable', 'false');
                    }
                }

                // Remove any previous children that aren't labels or the piece element
                Array.from(squareDiv.childNodes).forEach(node => {
                    if (node !== rankLabel && node !== fileLabel && node !== pieceElement && node.nodeType === Node.TEXT_NODE) {
                        squareDiv.removeChild(node);
                    }
                });

                // Highlighting is now handled by updateBoardHighlights()

                // Set the piece image
                if (pieceSymbol) {
                    pieceElement.innerHTML = pieceSymbol;
                } else {
                    pieceElement.innerHTML = '';
                }
            }
        }
        // Update board highlights
        updateBoardHighlights();

        // Update game status
        const status = document.getElementById('gameStatus');
        if (status) {
            if (chess.game_over()) {
                status.innerText = 'Game Over';
                if (chess.in_checkmate()) status.innerText += ': Checkmate';
                else if (chess.in_draw()) status.innerText += ': Draw';

                // Stop the clock when the game is over
                stopClock();
            } else {
                status.innerText = chess.turn() === 'w' ? 'White to move' : 'Black to move';
            }
        }

        // Update current turn and player info
        currentTurn = chess.turn();
        updatePlayerInfo();
    }

    // Function to process Style12 messages
    function processStyle12Message(msg) {
        console.log('Processing Style12 message, preferences.showStyle12Events =', showStyle12Events);

        // Initialize the board if it hasn't been done yet
        if (!boardInitialized) {
            initializeChessBoard();
        }

        // Update the chess board with the Style 12 data
        updateChessBoard(msg);

        // Also directly parse the Style 12 message for player info and clock times
        // This ensures the info is updated even if the board update fails
        parseStyle12Info(msg);
    }

    // Function to parse Style 12 messages for game information
    function parseStyle12Info(style12Message) {
        const lines = style12Message.split('\n');
        const boardLineIndex = lines.findIndex(line => line.trim().startsWith('<12>'));

        if (boardLineIndex !== -1) {
            const boardLine = lines[boardLineIndex].trim();
            const parts = boardLine.split(' ');

            // Log the Style 12 message for debugging
            console.log('Style 12 message:', boardLine);
            console.log('Parts length:', parts.length);

            // According to FICS Style 12 documentation:
            // https://www.freechess.org/Help/HelpFiles/style12.html
            // There are always exactly 31 non-empty fields separated by blanks

            if (parts.length >= 31) { // Make sure we have enough parts
                try {
                    // Extract all information from the Style 12 format
                    // Field 0: <12> identifier
                    // Fields 1-8: Board position (8 ranks)
                    // Field 9: Color to move (B or W)
                    const colorToMove = parts[9] === 'W' ? 'w' : 'b';

                    // Field 10: Double pawn push file or -1
                    const doublePawnPush = parseInt(parts[10], 10);

                    // Fields 11-14: Castling availability
                    const whiteCastleShort = parseInt(parts[11], 10);
                    const whiteCastleLong = parseInt(parts[12], 10);
                    const blackCastleShort = parseInt(parts[13], 10);
                    const blackCastleLong = parseInt(parts[14], 10);

                    // Field 15: Irreversible count (for 50-move rule)
                    const irreversibleCount = parseInt(parts[15], 10);

                    // Field 16: Game number
                    const gameNumber = parseInt(parts[16], 10);

                    // Fields 17-18: Player names
                    const whiteName = parts[17];
                    const blackName = parts[18];

                    // Field 19: My relation to this game
                    const relation = parseInt(parts[19], 10);

                    // Fields 20-21: Initial time and increment
                    const initialTime = parseInt(parts[20], 10);
                    const increment = parseInt(parts[21], 10);

                    // Fields 22-23: Material strength
                    const whiteMaterial = parseInt(parts[22], 10);
                    const blackMaterial = parseInt(parts[23], 10);

                    // Fields 24-25: Remaining time in seconds
                    // According to FICS Style12 format, these are in seconds
                    const whiteTimeSecs = parseFloat(parts[24]);
                    const blackTimeSecs = parseFloat(parts[25]);

                    console.log('Raw time values from Style12 - White:', parts[24], 'seconds, Black:', parts[25], 'seconds');

                    // Field 26: Move number
                    const moveNumber = parseInt(parts[26], 10);

                    // Field 27: Verbose coordinate notation for previous move
                    const lastMove = parts[27];

                    // Field 28: Time taken for previous move
                    const lastMoveTime = parts[28];

                    // Field 29: Pretty notation for previous move
                    const lastMovePretty = parts[29];
                    console.log('Parsed lastMovePretty from Style12:', lastMovePretty, 'from parts[29]:', parts[29]);

                    // Field 30: Board orientation (1 = Black at bottom, 0 = White at bottom)
                    const flipBoard = parseInt(parts[30], 10) === 1;

                    // Format clock times
                    const whiteTime = formatClockTime(whiteTimeSecs);
                    const blackTime = formatClockTime(blackTimeSecs);

                    console.log('Parsed Style 12 - White time:', whiteTime, 'Black time:', blackTime);

                    // Update global variables
                    whitePlayerName = whiteName;
                    blackPlayerName = blackName;

                    // Store the time in seconds for the clock timer
                    // Style12 times always take precedence over local timers
                    whiteTimeSeconds = whiteTimeSecs;
                    blackTimeSeconds = blackTimeSecs;
                    whitePlayerClock = whiteTime;
                    blackPlayerClock = blackTime;

                    console.log('Received new times from Style12 - White:', whiteTime, 'Black:', blackTime);

                    // Always stop any existing clock and restart with the new times
                    stopClock();
                    currentTurn = colorToMove;
                    updatePlayerInfo(); // Update UI with new times
                    startClock(); // Start the clock with the new times

                    // Update gameInfo object with all the parsed information
                    gameInfo = {
                        gameNumber,
                        initialTime,
                        increment,
                        whiteMaterial,
                        blackMaterial,
                        moveNumber,
                        lastMove,
                        lastMoveTime,
                        lastMovePretty,
                        relation,
                        doublePawnPush,
                        whiteCastleShort,
                        whiteCastleLong,
                        blackCastleShort,
                        blackCastleLong,
                        irreversibleCount
                    };

                    console.log('Updated gameInfo object with lastMovePretty:', gameInfo.lastMovePretty);

                    // Sounds will be played after animation completes

                    console.log('Updated game info:', gameInfo);
                    console.log('Last move pretty:', gameInfo.lastMovePretty);
                    console.log('Updated player info - White:', whitePlayerName, whitePlayerClock, 'Black:', blackPlayerName, blackPlayerClock, 'Turn:', currentTurn);

                    // Update the UI
                    updatePlayerInfo();
                } catch (e) {
                    console.error('Error parsing Style 12 message:', e);
                }
            } else {
                console.warn('Style 12 message has fewer than 31 parts:', parts.length);
            }
        }
    }

    // Function to start the clock timer
    function startClock() {
        if (isClockRunning) return; // Don't start if already running

        console.log('Starting clock for', currentTurn === 'w' ? 'White' : 'Black');
        isClockRunning = true;

        // Clear any existing timer
        if (clockTimer) {
            clearInterval(clockTimer);
        }

        // Start a new timer that ticks every second
        clockTimer = setInterval(() => {
            // Decrement the time of the player whose turn it is
            if (currentTurn === 'w') {
                whiteTimeSeconds = Math.max(0, whiteTimeSeconds - 1);
                whitePlayerClock = formatClockTime(whiteTimeSeconds);
                console.log('White clock tick:', whiteTimeSeconds, 'seconds =', whitePlayerClock);
            } else {
                blackTimeSeconds = Math.max(0, blackTimeSeconds - 1);
                blackPlayerClock = formatClockTime(blackTimeSeconds);
                console.log('Black clock tick:', blackTimeSeconds, 'seconds =', blackPlayerClock);
            }

            // Update the UI
            updatePlayerInfo();

            // Check for time forfeit
            if ((currentTurn === 'w' && whiteTimeSeconds <= 0) ||
                (currentTurn === 'b' && blackTimeSeconds <= 0)) {
                stopClock();
                console.log('Time forfeit for', currentTurn === 'w' ? 'White' : 'Black');
            }
        }, 1000); // Update every second
    }

    // Function to stop the clock timer
    function stopClock() {
        if (!isClockRunning) return; // Don't stop if not running

        console.log('Stopping clock');
        isClockRunning = false;

        // Clear the timer
        if (clockTimer) {
            clearInterval(clockTimer);
            clockTimer = null;
        }
    }

    // Function to restart the clock (stop and start)
    function restartClock() {
        stopClock();
        updatePlayerInfo(); // Update UI with current times
        startClock();
    }

    // Function to format clock time in MM:SS format
    function formatClockTime(seconds) {
        // Handle invalid input
        if (isNaN(seconds) || seconds < 0) {
            console.warn('Invalid time value:', seconds);
            return '05:00'; // Default to 5 minutes
        }

        // Convert seconds to minutes and seconds
        // For example, 624 seconds = 10 minutes and 24 seconds
        const minutes = Math.floor(seconds / 60);
        const remainingSeconds = Math.floor(seconds % 60);

        console.log(`Converting ${seconds} seconds to ${minutes}:${remainingSeconds}`);

        // Format as MM:SS
        return `${minutes.toString().padStart(2, '0')}:${remainingSeconds.toString().padStart(2, '0')}`;
    }

    // Function to update player info in the UI
    function updatePlayerInfo() {
        console.log('Updating player info UI');

        // Get the player info elements
        const topPlayerName = document.getElementById('topPlayerName');
        const topPlayerClock = document.getElementById('topPlayerClock');
        const bottomPlayerName = document.getElementById('bottomPlayerName');
        const bottomPlayerClock = document.getElementById('bottomPlayerClock');
        const topMoveIndicator = document.getElementById('topMoveIndicator');
        const bottomMoveIndicator = document.getElementById('bottomMoveIndicator');
        const lastMoveDisplay = document.getElementById('lastMoveDisplay');
        console.log('Player info elements:', {
            topPlayerName: topPlayerName ? 'found' : 'not found',
            topPlayerClock: topPlayerClock ? 'found' : 'not found',
            bottomPlayerName: bottomPlayerName ? 'found' : 'not found',
            bottomPlayerClock: bottomPlayerClock ? 'found' : 'not found',
            topMoveIndicator: topMoveIndicator ? 'found' : 'not found',
            bottomMoveIndicator: bottomMoveIndicator ? 'found' : 'not found',
            lastMoveDisplay: lastMoveDisplay ? 'found' : 'not found'
        });

        if (!topPlayerName || !topPlayerClock || !bottomPlayerName || !bottomPlayerClock ||
            !topMoveIndicator || !bottomMoveIndicator) {
            console.warn('Player info elements not found');
            return; // Elements not found
        }

        // Determine which player is on top/bottom based on myColor
        if (myColor === 'white') {
            // White pieces at bottom, black at top
            topPlayerName.innerText = blackPlayerName || 'Black';
            topPlayerClock.innerText = blackPlayerClock;
            bottomPlayerName.innerText = whitePlayerName || 'White';
            bottomPlayerClock.innerText = whitePlayerClock;

            // Set clock colors and move indicators based on whose turn it is
            topPlayerClock.style.color = currentTurn === 'b' ? '#32CD32' : '#800020'; // Lime green : Burgundy red
            bottomPlayerClock.style.color = currentTurn === 'w' ? '#32CD32' : '#800020'; // Lime green : Burgundy red

            // Update move indicators
            topMoveIndicator.style.backgroundColor = currentTurn === 'b' ? '#32CD32' : 'transparent'; // Lime green
            bottomMoveIndicator.style.backgroundColor = currentTurn === 'w' ? '#32CD32' : 'transparent'; // Lime green
        } else {
            // Black pieces at bottom, white at top
            topPlayerName.innerText = whitePlayerName || 'White';
            topPlayerClock.innerText = whitePlayerClock;
            bottomPlayerName.innerText = blackPlayerName || 'Black';
            bottomPlayerClock.innerText = blackPlayerClock;

            // Set clock colors and move indicators based on whose turn it is
            topPlayerClock.style.color = currentTurn === 'w' ? '#32CD32' : '#800020'; // Lime green : Burgundy red
            bottomPlayerClock.style.color = currentTurn === 'b' ? '#32CD32' : '#800020'; // Lime green : Burgundy red

            // Update move indicators
            topMoveIndicator.style.backgroundColor = currentTurn === 'w' ? '#32CD32' : 'transparent'; // Lime green
            bottomMoveIndicator.style.backgroundColor = currentTurn === 'b' ? '#32CD32' : 'transparent'; // Lime green
        }

        // Update last move display if available
        console.log('gameInfo:', gameInfo);
        console.log('lastMovePretty:', gameInfo ? gameInfo.lastMovePretty : 'gameInfo not available');

        if (lastMoveDisplay && gameInfo && gameInfo.lastMovePretty) {
            console.log('Setting last move display to:', gameInfo.lastMovePretty);
            lastMoveDisplay.innerText = `Last move: ${gameInfo.lastMovePretty}`;
        } else if (lastMoveDisplay) {
            console.log('Clearing last move display');
            lastMoveDisplay.innerText = '';
        }
    }

    // Track the previous board position to detect moves
    let previousPosition = null;

    function updateChessBoard(style12Message) {
        // Save the current position before updating
        if (chess) {
            previousPosition = chess.fen();
        }

        // Parse Style 12 message to update chess.js position
        const lines = style12Message.split('\n');
        const boardLineIndex = lines.findIndex(line => line.trim().startsWith('<12>'));

        if (boardLineIndex !== -1) {
            const boardLine = lines[boardLineIndex].trim();

            // Style 12 format: <12> [8 rows of board] [turn W/B] [other data...]
            const parts = boardLine.split(' ');

            if (parts.length >= 10) { // At least <12> + 8 rows + turn
                try {
                    // Extract the 8 rows of the board (parts[1] through parts[8])
                    const boardRows = parts.slice(1, 9);

                    // Convert Style 12 board representation to FEN
                    let fen = '';
                    for (let i = 0; i < 8; i++) {
                        let row = boardRows[i];
                        let emptyCount = 0;
                        let fenRow = '';

                        for (let j = 0; j < row.length; j++) {
                            const char = row.charAt(j);
                            if (char === '-') {
                                emptyCount++;
                            } else {
                                if (emptyCount > 0) {
                                    fenRow += emptyCount;
                                    emptyCount = 0;
                                }

                                // Convert FICS piece notation to FEN
                                // In FICS Style12: P=white pawn, p=black pawn, etc.
                                // In FEN: P=white pawn, p=black pawn, etc.
                                // So we can use the character directly
                                fenRow += char;
                            }
                        }

                        if (emptyCount > 0) {
                            fenRow += emptyCount;
                        }

                        fen += fenRow + (i < 7 ? '/' : '');
                    }

                    // Add turn
                    fen += ' ' + (parts[9] === 'W' ? 'w' : 'b');

                    // Add castling, en passant, halfmove, fullmove (simplified)
                    fen += ' KQkq - 0 1';

                    console.log("Generated FEN:", fen);

                    // Load the position into chess.js
                    try {
                        // Check if we have a previous position to animate from
                        if (previousPosition) {
                            // First load the new position
                            chess.load(fen);
                            console.log("Chess position loaded successfully");

                            // Then detect and animate the move
                            detectAndAnimateMove(previousPosition, chess.fen(), () => {
                                // Play sound after animation completes
                                if (gameInfo && gameInfo.lastMovePretty && gameInfo.lastMovePretty.includes('x')) {
                                    captureAudio.play();
                                } else {
                                    moveAudio.play();
                                }

                                // Update the board after animation completes
                                updateBoardFromChessJS();
                            });
                        } else {
                            // No previous position, just update the board
                            chess.load(fen);
                            console.log("Chess position loaded successfully");
                            updateBoardFromChessJS();
                        }
                    } catch (e) {
                        console.error("Failed to load FEN into chess.js:", e);
                        console.error("Invalid FEN:", fen);
                        // If loading fails, try a different approach or reset to starting position
                        try {
                            // Alternative approach: manually set up the board
                            chess.clear();

                            // Map board positions
                            for (let rank = 0; rank < 8; rank++) {
                                const row = boardRows[rank];
                                for (let file = 0; file < row.length; file++) {
                                    const char = row.charAt(file);
                                    if (char !== '-') {
                                        const square = String.fromCharCode(97 + file) + (8 - rank);
                                        const color = char === char.toUpperCase() ? 'w' : 'b';
                                        const pieceType = char.toLowerCase();
                                        chess.put({ type: pieceType, color: color }, square);
                                    }
                                }
                            }

                            // We can't directly set the turn in chess.js
                            // Instead, we'll create a new position with the correct turn

                            // Get the current position as FEN
                            let fen = chess.fen();
                            // Split the FEN string into its components
                            let fenParts = fen.split(' ');
                            // Set the turn (the 2nd component of the FEN string)
                            fenParts[1] = parts[9] === 'W' ? 'w' : 'b';
                            // Rejoin the FEN string
                            fen = fenParts.join(' ');
                            // Load the updated FEN
                            try {
                                chess.load(fen);
                            } catch (e) {
                                // If there's an error, just log it and continue
                                console.error('Error setting turn:', e);
                            }

                            // Set player color based on Style 12 message
                            // parts[9] is the current turn (W/B)
                            // parts[10] is -1 if it's the player's move, 1 if it's the opponent's move
                            if (parts.length > 10) {
                                const isPlayerMove = parts[10] === '-1';
                                if (parts[9] === 'W') {
                                    // If it's White's turn and it's the player's move, player is White
                                    // If it's White's turn and it's not the player's move, player is Black
                                    myColor = isPlayerMove ? 'white' : 'black';
                                } else {
                                    // If it's Black's turn and it's the player's move, player is Black
                                    // If it's Black's turn and it's not the player's move, player is White
                                    myColor = isPlayerMove ? 'black' : 'white';
                                }
                            }

                            // Just update the board
                            updateBoardFromChessJS();
                        } catch (e2) {
                            // If there's an error, reset the board
                            chess.reset();
                            updateBoardFromChessJS();
                        }
                    }

                    // Note: parseStyle12Info is now called directly from routeMessage
                    // to ensure it's always called, even if board update fails
                } catch (e) {
                    // Silently handle parsing errors
                }
            }
        }
    }

    // Function to update board highlights for selected squares and valid moves
    function updateBoardHighlights() {
        // Update all squares
        for (let rank = 8; rank >= 1; rank--) {
            for (let file = 1; file <= 8; file++) {
                const square = `${String.fromCharCode(96 + file)}${rank}`;
                const squareDiv = document.getElementById(`square-${file}-${rank}`);
                if (!squareDiv) continue;

                // Remove existing highlights
                squareDiv.classList.remove('selected', 'valid-move');

                // Add appropriate highlights
                if (square === selectedSquare || square === startSquare) {
                    squareDiv.classList.add('selected');
                } else if (validMoves.includes(square)) {
                    squareDiv.classList.add('valid-move');
                }
            }
        }
    }

    // Function to handle dropping a piece on a square
    function handleDrop(targetSquare) {
        // Check if the target square is a valid move
        if (validMoves.includes(targetSquare)) {
            // Check if this is a pawn promotion move
            const piece = draggedPiece;
            const rank = parseInt(targetSquare.charAt(1));
            const isPromotion = piece &&
                               piece.type === 'p' &&
                               ((piece.color === 'w' && rank === 8) ||
                                (piece.color === 'b' && rank === 1));

            if (isPromotion) {
                // Ask user what piece to promote to
                const promotionPiece = prompt('Promote pawn to: (q)ueen, (r)ook, (b)ishop, (n)knight', 'q');
                const validPromotions = ['q', 'r', 'b', 'n'];
                const promotion = validPromotions.includes(promotionPiece) ? promotionPiece : 'q';

                // Make move with promotion
                const move = {
                    from: startSquare,
                    to: targetSquare,
                    promotion: promotion
                };
                chess.move(move);
                ws.send(`move ${move.from}${move.to}=${promotion}\n\r`);
            } else {
                // Get the file and rank numbers for animation
                const fromFile = startSquare.charCodeAt(0) - 96;
                const fromRank = parseInt(startSquare.charAt(1));
                const toFile = targetSquare.charCodeAt(0) - 96;
                const toRank = parseInt(targetSquare.charAt(1));

                // Prepare animation data
                const fromSquare = { file: fromFile, rank: fromRank };
                const toSquare = { file: toFile, rank: toRank };

                // Make regular move
                const move = {
                    from: startSquare,
                    to: targetSquare
                };
                chess.move(move);
                ws.send(`move ${move.from}${move.to}\n\r`);

                // Animate the piece movement
                animatePieceMove(fromSquare, toSquare, () => {
                    // Play sound after animation completes
                    if (move.captured) {
                        captureAudio.play();
                    } else {
                        moveAudio.play();
                    }

                    // Update the board after animation completes
                    updateBoardFromChessJS();
                });
            }

            // Reset drag state
            draggedPiece = null;
            draggedPieceElement = null;
            startSquare = null;
            selectedSquare = null;
            validMoves = [];

            // Update the current turn and restart the clock
            currentTurn = chess.turn();
            restartClock(); // Restart the clock for the new player
        }
    }

    // Moves are made directly by clicking on the board or by dragging pieces

    // Hamburger menu functionality
    function setupPreferencesMenu() {
        const hamburgerMenu = document.getElementById('hamburgerMenu');
        const preferencesPanel = document.getElementById('preferencesPanel');
        const saveButton = document.getElementById('savePreferences');
        const prefPieceSet = document.getElementById('prefPieceSet');
        const prefLightSquare = document.getElementById('prefLightSquare');
        const prefDarkSquare = document.getElementById('prefDarkSquare');
        const lightSquarePreview = document.getElementById('lightSquarePreview');
        const darkSquarePreview = document.getElementById('darkSquarePreview');
        const prefCategories = document.querySelectorAll('.pref-category');
        const prefContents = document.querySelectorAll('.pref-content');

        // Toggle preferences panel
        hamburgerMenu.addEventListener('click', function() {
            preferencesPanel.classList.toggle('show');
            // Update the piece set preview when opening the panel
            if (preferencesPanel.classList.contains('show')) {
                updatePieceSetPreview(prefPieceSet.value);
            }
        });

        // Close panel when clicking outside
        document.addEventListener('click', function(event) {
            if (!preferencesPanel.contains(event.target) && event.target !== hamburgerMenu) {
                preferencesPanel.classList.remove('show');
            }
        });

        // Category tab switching
        prefCategories.forEach(category => {
            category.addEventListener('click', function() {
                // Remove active class from all categories
                prefCategories.forEach(cat => cat.classList.remove('active'));
                // Add active class to clicked category
                this.classList.add('active');

                // Hide all content sections
                prefContents.forEach(content => content.classList.remove('active'));
                // Show the selected content section
                const categoryName = this.getAttribute('data-category');
                document.getElementById(`pref-${categoryName}`).classList.add('active');
            });
        });

        // Update color previews
        prefLightSquare.addEventListener('input', function() {
            lightSquarePreview.style.backgroundColor = this.value;
        });

        prefDarkSquare.addEventListener('input', function() {
            darkSquarePreview.style.backgroundColor = this.value;
        });

        // Update piece set preview when selection changes
        prefPieceSet.addEventListener('change', function() {
            updatePieceSetPreview(this.value);
        });

        // Save preferences
        saveButton.addEventListener('click', function() {
            currentPieceSet = prefPieceSet.value;
            lightSquareColor = prefLightSquare.value;
            darkSquareColor = prefDarkSquare.value;

            savePreferences();
            applyPreferences();
            preferencesPanel.classList.remove('show');
        });
    }

    // Function to update the piece set preview grid
    function updatePieceSetPreview(pieceSet) {
        const pieceTypes = [
            { id: 'preview-bR', piece: 'bR' },
            { id: 'preview-bN', piece: 'bN' },
            { id: 'preview-bB', piece: 'bB' },
            { id: 'preview-bQ', piece: 'bQ' },
            { id: 'preview-bK', piece: 'bK' },
            { id: 'preview-bP', piece: 'bP' },
            { id: 'preview-wP', piece: 'wP' },
            { id: 'preview-wR', piece: 'wR' },
            { id: 'preview-wN', piece: 'wN' },
            { id: 'preview-wB', piece: 'wB' },
            { id: 'preview-wQ', piece: 'wQ' },
            { id: 'preview-wK', piece: 'wK' }
        ];

        // Update each piece image in the preview grid
        pieceTypes.forEach(item => {
            // Find all elements with this ID (for pawns we have multiple)
            const elements = document.querySelectorAll(`#${item.id}`);
            elements.forEach(element => {
                element.src = `pieces/${pieceSet}/${item.piece}.svg`;
            });
        });
    }

    // Create a default chess tab with starting position
    function createDefaultChessTab() {
        // Create a game tab with "Practice" as the opponent name
        createGameTab("Practice");

        // Reset the chess board to the starting position
        chess.reset();

        // Set default player names and clocks for practice board
        whitePlayerName = 'White';
        blackPlayerName = 'Black';
        whiteTimeSeconds = 300; // 5 minutes in seconds
        blackTimeSeconds = 300; // 5 minutes in seconds
        whitePlayerClock = formatClockTime(whiteTimeSeconds);
        blackPlayerClock = formatClockTime(blackTimeSeconds);
        currentTurn = 'w';

        // Start the clock for the practice board
        restartClock();

        // Update the board display
        updateBoardFromChessJS();

        // Update the game status
        const status = document.getElementById('gameStatus');
        if (status) {
            status.innerText = 'Practice board - White to move';
        }
    }

    // Test function to verify clock time parsing
    function testClockParsing() {
        const testStyle12 = "<12> ------k- -p--r-pp p-p----- -------n ----B--- ------P- PPPq---P -K--R--- W -1 0 0 0 0 1 10 venugopal kunde 0 15 0 13 22 624 769 27 Q/g5-d2 (0:04) Qd2 0 1 112";
        const parts = testStyle12.split(' ');

        // Fields 24-25 should be the clock times in seconds
        const whiteTimeSecs = parseFloat(parts[24]); // 624 seconds = 10 minutes and 24 seconds
        const blackTimeSecs = parseFloat(parts[25]); // 769 seconds = 12 minutes and 49 seconds

        console.log('Test Style12 parsing:');
        console.log('Raw time values - White:', parts[24], 'seconds, Black:', parts[25], 'seconds');
        console.log('White time calculation:', whiteTimeSecs, 'seconds =', Math.floor(whiteTimeSecs / 60), 'minutes and', Math.floor(whiteTimeSecs % 60), 'seconds');
        console.log('Black time calculation:', blackTimeSecs, 'seconds =', Math.floor(blackTimeSecs / 60), 'minutes and', Math.floor(blackTimeSecs % 60), 'seconds');
        console.log('Formatted times - White:', formatClockTime(whiteTimeSecs), 'Black:', formatClockTime(blackTimeSecs));
        console.log('Expected times - White: 10:24, Black: 12:49');
    }

    // Function to initialize the chess board
    function initializeChessBoard() {
        if (boardInitialized) return; // Don't initialize twice

        const boardArea = document.querySelector('.chess-board-area');
        if (!boardArea) return;

        // Clear any existing content
        boardArea.innerHTML = '';

        // Create main board container
        const boardMainContainer = document.createElement('div');
        boardMainContainer.classList.add('grid-row');
        boardMainContainer.style.display = 'flex';
        boardMainContainer.style.flexDirection = 'column';
        boardMainContainer.style.alignItems = 'center';
        boardMainContainer.style.width = '100%';
        boardMainContainer.style.minWidth = '0'; // Allow container to shrink below content size
        boardMainContainer.style.overflow = 'hidden'; // Prevent overflow

        // Create board container with horizontal layout
        const boardContainer = document.createElement('div');
        boardContainer.style.flexShrink = '1'; // Allow shrinking
        boardContainer.style.width = '100%';
        boardContainer.style.display = 'flex';
        boardContainer.style.flexDirection = 'row'; // Changed to row for horizontal layout
        boardContainer.style.alignItems = 'flex-start';
        boardContainer.style.minWidth = '0'; // Allow container to shrink below content size
        boardContainer.style.overflow = 'hidden'; // Prevent overflow

        // Create a container for the board itself
        const boardOnlyContainer = document.createElement('div');
        boardOnlyContainer.style.display = 'flex';
        boardOnlyContainer.style.flexDirection = 'column';
        boardOnlyContainer.style.alignItems = 'center';
        boardOnlyContainer.style.flexShrink = '0';
        boardOnlyContainer.style.position = 'relative';

        // Create a container for player info on the right
        const playerInfoContainer = document.createElement('div');
        playerInfoContainer.style.display = 'flex';
        playerInfoContainer.style.flexDirection = 'column';
        playerInfoContainer.style.marginLeft = '20px';
        playerInfoContainer.style.padding = '5px';
        playerInfoContainer.style.minWidth = '200px';
        playerInfoContainer.style.justifyContent = 'center'; // Center content vertically
        playerInfoContainer.style.height = '100%';

        // Create top player info container
        const topPlayerInfo = document.createElement('div');
        topPlayerInfo.classList.add('player-info');
        topPlayerInfo.classList.add('top-player');
        topPlayerInfo.style.display = 'flex';
        topPlayerInfo.style.flexDirection = 'column';
        topPlayerInfo.style.padding = '2px';
        topPlayerInfo.style.marginBottom = '0px'; // Removed margin as the divider now has its own margin
        topPlayerInfo.style.border = 'none';
        topPlayerInfo.style.borderRadius = '4px';
        topPlayerInfo.style.width = '100%';
        topPlayerInfo.style.boxSizing = 'border-box'; // Include padding in width calculation

        // Top player name with move indicator
        const topPlayerNameWrapper = document.createElement('div');
        topPlayerNameWrapper.style.display = 'flex';
        topPlayerNameWrapper.style.alignItems = 'center';
        topPlayerNameWrapper.style.gap = '3px'; // Minimal gap between indicator and name
        topPlayerNameWrapper.style.paddingLeft = '7px'; // Reduced by additional 15%

        const topPlayerName = document.createElement('div');
        topPlayerName.classList.add('player-name');
        topPlayerName.id = 'topPlayerName';
        topPlayerName.innerText = 'Opponent';
        topPlayerName.style.fontWeight = 'bold';
        topPlayerName.style.fontSize = 'calc(1.3em * var(--font-scale, 1))'; // Increased from 1.1em to 1.3em
        topPlayerName.style.color = '#333';

        // Create move indicator for top player
        const topMoveIndicator = document.createElement('div');
        topMoveIndicator.id = 'topMoveIndicator';
        topMoveIndicator.style.width = 'calc(12px * var(--font-scale, 1))';
        topMoveIndicator.style.height = 'calc(12px * var(--font-scale, 1))';
        topMoveIndicator.style.borderRadius = '50%';
        topMoveIndicator.style.border = '2px solid #333';
        topMoveIndicator.style.backgroundColor = 'transparent'; // Empty by default
        topMoveIndicator.style.display = 'inline-block';
        topMoveIndicator.style.verticalAlign = 'middle';

        topPlayerNameWrapper.appendChild(topMoveIndicator);
        topPlayerNameWrapper.appendChild(topPlayerName);

        // Top player clock
        const topPlayerClock = document.createElement('div');
        topPlayerClock.classList.add('player-clock');
        topPlayerClock.id = 'topPlayerClock';
        topPlayerClock.innerText = '00:00';
        topPlayerClock.style.fontFamily = '"Digital", "Orbitron", "Share Tech Mono", monospace'; // Digital LED-style fonts
        topPlayerClock.style.fontWeight = 'bold';
        topPlayerClock.style.fontSize = 'calc(4em * var(--font-scale, 1))'; // 10% bigger than previous 3.6em
        topPlayerClock.style.paddingRight = '20px'; // Increased right padding
        topPlayerClock.style.paddingLeft = '7px'; // Reduced by additional 15%
        topPlayerClock.style.marginBottom = '4px'; // Reduced by additional 15%
        topPlayerClock.style.letterSpacing = '0.05em'; // Slightly increase letter spacing for LED look
        topPlayerClock.style.textShadow = '0 0 5px rgba(50, 205, 50, 0.7)'; // Add glow effect for active player

        // Add clock first, then name wrapper (clock above name)
        topPlayerInfo.appendChild(topPlayerClock);
        topPlayerInfo.appendChild(topPlayerNameWrapper);

        // Create the chess board
        const board = document.createElement('div');
        board.id = 'chessBoard';
        board.classList.add('chess-board');
        board.style.width = '100%';
        board.style.maxWidth = '1500px'; // Maximum size
        board.style.aspectRatio = '1 / 1'; // Maintain square aspect ratio

        // Create bottom player info container
        const bottomPlayerInfo = document.createElement('div');
        bottomPlayerInfo.classList.add('player-info');
        bottomPlayerInfo.classList.add('bottom-player');
        bottomPlayerInfo.style.display = 'flex';
        bottomPlayerInfo.style.flexDirection = 'column';
        bottomPlayerInfo.style.padding = '2px';
        bottomPlayerInfo.style.marginTop = '0px'; // Removed margin as the divider now has its own margin
        bottomPlayerInfo.style.border = 'none';
        bottomPlayerInfo.style.borderRadius = '4px';
        bottomPlayerInfo.style.width = '100%';
        bottomPlayerInfo.style.boxSizing = 'border-box'; // Include padding in width calculation

        // Bottom player name with move indicator
        const bottomPlayerNameWrapper = document.createElement('div');
        bottomPlayerNameWrapper.style.display = 'flex';
        bottomPlayerNameWrapper.style.alignItems = 'center';
        bottomPlayerNameWrapper.style.gap = '3px'; // Minimal gap between indicator and name
        bottomPlayerNameWrapper.style.paddingLeft = '7px'; // Reduced by additional 15%

        const bottomPlayerName = document.createElement('div');
        bottomPlayerName.classList.add('player-name');
        bottomPlayerName.id = 'bottomPlayerName';
        bottomPlayerName.innerText = 'You';
        bottomPlayerName.style.fontWeight = 'bold';
        bottomPlayerName.style.fontSize = 'calc(1.3em * var(--font-scale, 1))'; // Increased from 1.1em to 1.3em
        bottomPlayerName.style.color = '#333';

        // Create move indicator for bottom player
        const bottomMoveIndicator = document.createElement('div');
        bottomMoveIndicator.id = 'bottomMoveIndicator';
        bottomMoveIndicator.style.width = 'calc(12px * var(--font-scale, 1))';
        bottomMoveIndicator.style.height = 'calc(12px * var(--font-scale, 1))';
        bottomMoveIndicator.style.borderRadius = '50%';
        bottomMoveIndicator.style.border = '2px solid #333';
        bottomMoveIndicator.style.backgroundColor = 'transparent'; // Empty by default
        bottomMoveIndicator.style.display = 'inline-block';
        bottomMoveIndicator.style.verticalAlign = 'middle';

        bottomPlayerNameWrapper.appendChild(bottomMoveIndicator);
        bottomPlayerNameWrapper.appendChild(bottomPlayerName);

        // Bottom player clock
        const bottomPlayerClock = document.createElement('div');
        bottomPlayerClock.classList.add('player-clock');
        bottomPlayerClock.id = 'bottomPlayerClock';
        bottomPlayerClock.innerText = '00:00';
        bottomPlayerClock.style.fontFamily = '"Digital", "Orbitron", "Share Tech Mono", monospace'; // Digital LED-style fonts
        bottomPlayerClock.style.fontWeight = 'bold';
        bottomPlayerClock.style.fontSize = 'calc(4em * var(--font-scale, 1))'; // 10% bigger than previous 3.6em
        bottomPlayerClock.style.paddingRight = '20px'; // Increased right padding
        bottomPlayerClock.style.paddingLeft = '7px'; // Reduced by additional 15%
        bottomPlayerClock.style.marginTop = '4px'; // Reduced by additional 15%
        bottomPlayerClock.style.letterSpacing = '0.05em'; // Slightly increase letter spacing for LED look
        bottomPlayerClock.style.textShadow = '0 0 5px rgba(50, 205, 50, 0.7)'; // Add glow effect for active player

        bottomPlayerInfo.appendChild(bottomPlayerNameWrapper);
        bottomPlayerInfo.appendChild(bottomPlayerClock);

        // Create last move display (outside the player info container)
        const lastMoveDisplay = document.createElement('div');
        lastMoveDisplay.classList.add('last-move');
        lastMoveDisplay.id = 'lastMoveDisplay';
        lastMoveDisplay.innerText = '';
        lastMoveDisplay.style.fontSize = '0.9em';
        lastMoveDisplay.style.color = '#666';
        lastMoveDisplay.style.marginTop = '5px';
        lastMoveDisplay.style.textAlign = 'right';
        lastMoveDisplay.style.width = '100%';
        lastMoveDisplay.style.minWidth = '0';
        lastMoveDisplay.style.boxSizing = 'border-box';
        lastMoveDisplay.style.paddingRight = '5px';

        // Create board menu button
        const boardMenuButton = document.createElement('button');
        boardMenuButton.classList.add('board-menu-button');
        boardMenuButton.innerHTML = '⋮'; // Vertical ellipsis for menu
        boardMenuButton.title = 'Board Menu';
        boardMenuButton.style.position = 'static'; // Override the absolute positioning
        boardMenuButton.style.top = 'auto';
        boardMenuButton.style.right = 'auto';
        boardMenuButton.style.marginLeft = 'auto'; // Push to the right in flex container

        // Create board menu
        const boardMenu = document.createElement('div');
        boardMenu.classList.add('board-menu');

        // Reset button
        const resetBtn = document.createElement('button');
        resetBtn.title = 'Reset Board';
        resetBtn.innerHTML = '<i class="material-icons">restart_alt</i> Reset Board';
        resetBtn.onclick = () => {
            chess.reset();
            updateBoardFromChessJS();
            boardMenu.classList.remove('show'); // Hide menu after action
        };
        boardMenu.appendChild(resetBtn);

        // Flip board button
        const flipBtn = document.createElement('button');
        flipBtn.title = 'Flip Board';
        flipBtn.innerHTML = '<i class="material-icons">swap_vert</i> Flip Board';
        flipBtn.onclick = () => {
            // Send flip command to FICS
            ws.send('flip\n\r');

            // Send refresh command after a short delay to ensure the board is updated
            setTimeout(() => {
                ws.send('refresh\n\r');
                console.log('Sent refresh command after flip');
            }, 300);

            // Also update local board orientation
            myColor = myColor === 'white' ? 'black' : 'white';
            updateBoardFromChessJS();
            updatePlayerInfo();
            boardMenu.classList.remove('show'); // Hide menu after action
        };
        boardMenu.appendChild(flipBtn);

        // Toggle menu when button is clicked
        boardMenuButton.addEventListener('click', (event) => {
            boardMenu.classList.toggle('show');
            event.stopPropagation(); // Prevent the document click handler from firing
        });

        // Close menu when clicking outside
        document.addEventListener('click', (event) => {
            if (!boardMenuButton.contains(event.target) && !boardMenu.contains(event.target)) {
                boardMenu.classList.remove('show');
            }
        });

        // Add board to the board-only container
        boardOnlyContainer.appendChild(board);
        boardOnlyContainer.appendChild(lastMoveDisplay);

        // Create a divider box between the players
        const playerDivider = document.createElement('div');
        playerDivider.style.width = '90%'; // Slightly narrower than full width to allow for resizing
        playerDivider.style.height = '150px'; // Increased height by 25% (from 120px to 150px)
        playerDivider.style.margin = '5px 0'; // Reduced margin and left-aligned
        playerDivider.style.backgroundColor = 'white';
        playerDivider.style.border = 'none'; // Remove default border
        playerDivider.style.boxShadow = '0 4px 6px rgba(0, 0, 0, .75)'; // Match chessboard shadow
        playerDivider.style.borderRadius = '10px'; // Match chessboard border radius
        playerDivider.style.padding = '5px 10px'; // Reduced padding
        playerDivider.style.display = 'flex'; // Prepare for content
        playerDivider.style.alignItems = 'center'; // Center content vertically
        playerDivider.style.justifyContent = 'center'; // Center content horizontally

        // Create containers for player names to be positioned at the top and bottom of the divider
        const topPlayerNameContainer = document.createElement('div');
        topPlayerNameContainer.classList.add('top-name-container');
        topPlayerNameContainer.style.position = 'absolute';
        topPlayerNameContainer.style.top = '5px'; // Reduced margin from 15px to 5px
        topPlayerNameContainer.style.left = '0';
        topPlayerNameContainer.style.width = '100%';
        topPlayerNameContainer.style.textAlign = 'left';
        topPlayerNameContainer.style.padding = '2px 10px'; // Reduced padding
        topPlayerNameContainer.style.boxSizing = 'border-box';
        topPlayerNameContainer.style.display = 'flex';
        topPlayerNameContainer.style.justifyContent = 'space-between';
        topPlayerNameContainer.style.alignItems = 'center';

        const bottomPlayerNameContainer = document.createElement('div');
        bottomPlayerNameContainer.classList.add('bottom-name-container');
        bottomPlayerNameContainer.style.position = 'absolute';
        bottomPlayerNameContainer.style.bottom = '5px'; // Reduced margin from 15px to 5px
        bottomPlayerNameContainer.style.left = '0';
        bottomPlayerNameContainer.style.width = '100%';
        bottomPlayerNameContainer.style.textAlign = 'left';
        bottomPlayerNameContainer.style.padding = '2px 10px'; // Reduced padding
        bottomPlayerNameContainer.style.boxSizing = 'border-box';

        // Move the player names and wrappers to the divider
        topPlayerNameContainer.appendChild(topPlayerNameWrapper);
        topPlayerNameContainer.appendChild(boardMenuButton); // Add menu button to the right of top player name
        bottomPlayerNameContainer.appendChild(bottomPlayerNameWrapper);

        // Add menu to the divider (it will be positioned by its own CSS)
        playerDivider.appendChild(boardMenu);

        // Make the divider position relative to contain the absolute positioned elements
        playerDivider.style.position = 'relative';

        // Add the name containers to the divider
        playerDivider.appendChild(topPlayerNameContainer);
        playerDivider.appendChild(bottomPlayerNameContainer);

        // Add player info and divider to the player info container
        playerInfoContainer.appendChild(topPlayerClock);
        playerInfoContainer.appendChild(playerDivider);
        playerInfoContainer.appendChild(bottomPlayerClock);

        // Add both containers to the main board container
        boardContainer.appendChild(boardOnlyContainer);
        boardContainer.appendChild(playerInfoContainer);

        // Add board container to the main container
        boardMainContainer.appendChild(boardContainer);

        // Add the container to the board area
        boardArea.appendChild(boardMainContainer);

        // Initialize the chess board
        createChessBoard(board);

        // Add resize observer to adjust board size when container changes
        const resizeObserver = new ResizeObserver(() => {
            // Get the available width in the chess board area
            const chessBoardArea = document.querySelector('.chess-board-area');
            if (!chessBoardArea) return;

            // Get the available width and height, accounting for padding and player info panel
            const availableWidth = chessBoardArea.clientWidth - 400; // Subtract padding and player info width (increased for larger clock)
            const availableHeight = chessBoardArea.clientHeight - 40; // Subtract padding

            // Ensure we never try to use more width than is available
            const maxWidth = Math.max(100, availableWidth); // Minimum size of 100px

            // Calculate the maximum size that fits while maintaining square aspect ratio
            const maxSize = Math.min(maxWidth, availableHeight, 1500); // Cap at 1500px

            // Update board size
            board.style.width = maxSize + 'px';
            board.style.height = maxSize + 'px';

            // Calculate font scale based on board size (relative to 800px baseline)
            // Apply a 0.75 factor to make fonts 25% smaller overall
            const fontScale = Math.max(0.45, Math.min(1.125, maxSize / 800 * 0.75));
            document.documentElement.style.setProperty('--font-scale', fontScale);

            // Update player info container height to match board height
            playerInfoContainer.style.height = maxSize + 'px';

            // Update board-only container width
            boardOnlyContainer.style.width = maxSize + 'px';

            // Set player info container width (scaled with board size)
            const minInfoWidth = 200;
            const maxInfoWidth = 350;
            const baseInfoWidth = 300;
            playerInfoContainer.style.width = Math.max(minInfoWidth, Math.min(maxInfoWidth, baseInfoWidth * fontScale)) + 'px';

            // Also adjust the margin between board and player info based on available space
            playerInfoContainer.style.marginLeft = Math.max(5, Math.min(20, 15 * fontScale)) + 'px';

            // Scale the divider box with the board size
            const boxScale = Math.max(0.6, Math.min(1.5, maxSize / 800));
            playerDivider.style.height = (150 * boxScale) + 'px';
            // Scale the divider box width based on available space
            const boxWidthScale = Math.max(0.7, Math.min(1, maxSize / 800));
            playerDivider.style.width = (100 * boxWidthScale) + '%'; // Scale width with board size
            playerDivider.style.borderRadius = Math.max(5, Math.min(15, 10 * boxScale)) + 'px'; // Scale border radius
            playerDivider.style.boxShadow = `0 ${Math.max(2, 4 * boxScale)}px ${Math.max(3, 6 * boxScale)}px rgba(0, 0, 0, .75)`; // Scale shadow
            playerDivider.style.padding = `${Math.max(3, 5 * boxScale)}px ${Math.max(5, 10 * boxScale)}px`;

            // Update the name containers' positioning based on box scale
            const topNameContainer = playerDivider.querySelector('.top-name-container');
            const bottomNameContainer = playerDivider.querySelector('.bottom-name-container');
            if (topNameContainer) {
                topNameContainer.style.top = (5 * boxScale) + 'px';
                topNameContainer.style.padding = `${Math.max(1, 2 * boxScale)}px ${Math.max(5, 10 * boxScale)}px`;
            }
            if (bottomNameContainer) {
                bottomNameContainer.style.bottom = (5 * boxScale) + 'px';
                bottomNameContainer.style.padding = `${Math.max(1, 2 * boxScale)}px ${Math.max(5, 10 * boxScale)}px`;
            }

            // Force a redraw of the board
            updateBoardFromChessJS();
        });

        // Observe the chess board area for size changes
        resizeObserver.observe(document.querySelector('.chess-board-area'));

        // Also trigger resize when the window is resized
        window.addEventListener('resize', () => {
            resizeObserver.disconnect();
            setTimeout(() => {
                resizeObserver.observe(document.querySelector('.chess-board-area'));
            }, 100);
        });

        // Set default player names and clocks
        whitePlayerName = 'White';
        blackPlayerName = 'Black';
        whiteTimeSeconds = 300; // 5 minutes in seconds
        blackTimeSeconds = 300; // 5 minutes in seconds
        whitePlayerClock = formatClockTime(whiteTimeSeconds);
        blackPlayerClock = formatClockTime(blackTimeSeconds);
        currentTurn = 'w';

        // Reset the chess board to the starting position
        chess.reset();
        updateBoardFromChessJS();

        // Start the clock
        restartClock();

        boardInitialized = true;
    }

    window.onload = function() {
        // Run the test function
        testClockParsing();

        connectWebSocket();
        loadPreferences();
        setupPreferencesMenu();

        // Initialize tabs visibility (should hide chat tabs initially)
        updateTabsVisibility();

        // Initialize the chess board
        setTimeout(initializeChessBoard, 500); // Small delay to ensure DOM is fully loaded
    };
</script>
</body>
</html>
